import{_ as b}from"./ValaxyMain.vue_vue_type_style_index_0_lang.DXFDIcRI.js";import{f as m,a as k,u as f}from"./chunks/vue-router.CE6eJGTm.js";import{O as v,a4 as e,V as r,U as a,X as l,u as _,P as g,A as j}from"./framework.CgPPQfmH.js";import"./app.2Hk-Pb-P.js";import"./chunks/dayjs.CCYrSalk.js";import"./chunks/vue-i18n.BoM8szIi.js";import"./chunks/pinia.BjFmakTL.js";import"./chunks/@vueuse/motion.Cp--YhDB.js";import"./chunks/nprogress.BahbDzmd.js";import"./YunComment.vue_vue_type_style_index_0_lang.DC8N30BB.js";import"./index.C5okkQwF.js";import"./YunPageHeader.vue_vue_type_script_setup_true_lang.PEAAi8W5.js";import"./post.CGlAV6UI.js";const P=m("/posts/study notes/java base knowledge/java basic knowledge",async t=>JSON.parse('{"title":"java基础","description":"","frontmatter":{"title":"java基础","date":"2025-04-19","updated":"2025-04-19","categories":"java","tags":["java","笔记"],"top":1},"headers":[{"level":2,"title":"基础知识","slug":"基础知识","link":"#基础知识","children":[{"level":3,"title":"1、面向对象、面向过程","slug":"_1、面向对象、面向过程","link":"#_1、面向对象、面向过程","children":[]},{"level":3,"title":"2、jvm、jre、jdk","slug":"_2、jvm、jre、jdk","link":"#_2、jvm、jre、jdk","children":[]},{"level":3,"title":"3、构造方法","slug":"_3、构造方法","link":"#_3、构造方法","children":[]},{"level":3,"title":"4、java中创建对象的方法","slug":"_4、java中创建对象的方法","link":"#_4、java中创建对象的方法","children":[]},{"level":3,"title":"5、final、finally、finalize的区别","slug":"_5、final、finally、finalize的区别","link":"#_5、final、finally、finalize的区别","children":[]},{"level":3,"title":"6、&和&&区别","slug":"_6、-和-区别","link":"#_6、-和-区别","children":[]},{"level":3,"title":"7、java中参数传递值还是引用","slug":"_7、java中参数传递值还是引用","link":"#_7、java中参数传递值还是引用","children":[]},{"level":3,"title":"8、如何实现对象的拷贝","slug":"_8、如何实现对象的拷贝","link":"#_8、如何实现对象的拷贝","children":[]},{"level":3,"title":"9、对象的创建过程","slug":"_9、对象的创建过程","link":"#_9、对象的创建过程","children":[]},{"level":3,"title":"10、java有没有指针","slug":"_10、java有没有指针","link":"#_10、java有没有指针","children":[]},{"level":3,"title":"11、修饰符","slug":"_11、修饰符","link":"#_11、修饰符","children":[]},{"level":3,"title":"12、序列化和反序列化","slug":"_12、序列化和反序列化","link":"#_12、序列化和反序列化","children":[]},{"level":3,"title":"13、java跨平台","slug":"_13、java跨平台","link":"#_13、java跨平台","children":[]},{"level":3,"title":"14、static关键字的作用","slug":"_14、static关键字的作用","link":"#_14、static关键字的作用","children":[]},{"level":3,"title":"15、环境变量path","slug":"_15、环境变量path","link":"#_15、环境变量path","children":[]},{"level":3,"title":"16、多态性和虚函数","slug":"_16、多态性和虚函数","link":"#_16、多态性和虚函数","children":[]},{"level":3,"title":"1、数据类型、包装类","slug":"_1、数据类型、包装类","link":"#_1、数据类型、包装类","children":[]},{"level":3,"title":"2、equals和==","slug":"_2、equals和","link":"#_2、equals和","children":[]},{"level":3,"title":"3、抽象类和接口的区别","slug":"_3、抽象类和接口的区别","link":"#_3、抽象类和接口的区别","children":[]},{"level":3,"title":"4、变量","slug":"_4、变量","link":"#_4、变量","children":[]},{"level":3,"title":"5、object类的常用方法","slug":"_5、object类的常用方法","link":"#_5、object类的常用方法","children":[]},{"level":3,"title":"6、遍历数组的方法","slug":"_6、遍历数组的方法","link":"#_6、遍历数组的方法","children":[]},{"level":3,"title":"7、java中参数传递值还是传引用","slug":"_7、java中参数传递值还是传引用","link":"#_7、java中参数传递值还是传引用","children":[]},{"level":3,"title":"8、集合框架Collection、map","slug":"_8、集合框架collection、map","link":"#_8、集合框架collection、map","children":[]},{"level":3,"title":"9、String类","slug":"_9、string类","link":"#_9、string类","children":[]},{"level":3,"title":"10、数组和链表的使用场景和优缺点","slug":"_10、数组和链表的使用场景和优缺点","link":"#_10、数组和链表的使用场景和优缺点","children":[]},{"level":3,"title":"11、collections","slug":"_11、collections","link":"#_11、collections","children":[]},{"level":3,"title":"12、如何设计消息队列","slug":"_12、如何设计消息队列","link":"#_12、如何设计消息队列","children":[]},{"level":3,"title":"13、jdk并发容器","slug":"_13、jdk并发容器","link":"#_13、jdk并发容器","children":[]},{"level":3,"title":"14、hashmap一系列问题","slug":"_14、hashmap一系列问题","link":"#_14、hashmap一系列问题","children":[]}]}],"relativePath":"pages/posts/study notes/java base knowledge/java basic knowledge.md","lastUpdated":1745542762000}'),{lazy:(t,h)=>t.name===h.name}),B={__name:"java basic knowledge",setup(t,{expose:h}){var d;const{data:s}=P(),p=f(),u=k(),i=Object.assign(u.meta.frontmatter||{},((d=s.value)==null?void 0:d.frontmatter)||{});return u.meta.frontmatter=i,p.currentRoute.value.data=s.value,j("valaxy:frontmatter",i),globalThis.$frontmatter=i,h({frontmatter:{title:"java基础",date:"2025-04-19",updated:"2025-04-19",categories:"java",tags:["java","笔记"],top:1}}),(n,o)=>{const c=b;return g(),v(c,{frontmatter:_(i)},{"main-content-md":e(()=>o[0]||(o[0]=[a("h2",{id:"基础知识",tabindex:"-1"},[l("基础知识 "),a("a",{class:"header-anchor",href:"#基础知识","aria-label":'Permalink to "基础知识"'},"​")],-1),a("h3",{id:"_1、面向对象、面向过程",tabindex:"-1"},[l("1、面向对象、面向过程 "),a("a",{class:"header-anchor",href:"#_1、面向对象、面向过程","aria-label":'Permalink to "1、面向对象、面向过程"'},"​")],-1),a("h4",{id:"区别",tabindex:"-1"},[l("区别 "),a("a",{class:"header-anchor",href:"#区别","aria-label":'Permalink to "区别"'},"​")],-1),a("p",null,"面向过程：实现函数开发的",-1),a("p",null,"面向对象：一种编程指导思想，将具体的实物抽象为类并具有属性和方法，通过实例化完成功能",-1),a("p",null,"分别从业务、设计、开发角度进行理解",-1),a("p",null,"业务：对真实的业务概念抽象成对象，业务需求变化可以通过增加、修改或替换对象来实现",-1),a("p",null,"设计：模块化和封装、将系统划分为多个对象，并定义它们之间的关系",-1),a("p",null,"开发：类、继承、多态",-1),a("h4",{id:"面向对象特性",tabindex:"-1"},[l("面向对象特性 "),a("a",{class:"header-anchor",href:"#面向对象特性","aria-label":'Permalink to "面向对象特性"'},"​")],-1),a("h4",{id:"多态",tabindex:"-1"},[l("多态 "),a("a",{class:"header-anchor",href:"#多态","aria-label":'Permalink to "多态"'},"​")],-1),a("p",null,"编译时多态（方法的重载），运行时多态（方法的重写）",-1),a("h5",{id:"重载",tabindex:"-1"},[l("重载 "),a("a",{class:"header-anchor",href:"#重载","aria-label":'Permalink to "重载"'},"​")],-1),a("p",null,"参数不同 方法相同",-1),a("h5",{id:"重写",tabindex:"-1"},[l("重写 "),a("a",{class:"header-anchor",href:"#重写","aria-label":'Permalink to "重写"'},"​")],-1),a("p",null,"子类重写父类",-1),a("h4",{id:"继承",tabindex:"-1"},[l("继承 "),a("a",{class:"header-anchor",href:"#继承","aria-label":'Permalink to "继承"'},"​")],-1),a("p",null,"从已有类的信息创建新类的过程，子类继承父类",-1),a("h4",{id:"封装",tabindex:"-1"},[l("封装 "),a("a",{class:"header-anchor",href:"#封装","aria-label":'Permalink to "封装"'},"​")],-1),a("p",null,"封装数据和方法，对外提供接口",-1),a("h3",{id:"_2、jvm、jre、jdk",tabindex:"-1"},[l("2、jvm、jre、jdk "),a("a",{class:"header-anchor",href:"#_2、jvm、jre、jdk","aria-label":'Permalink to "2、jvm、jre、jdk"'},"​")],-1),a("p",null,"jdk：java开发工具包，整个java运行的核心，包含运行时jre和java基础类库",-1),a("p",null,"jre：java运行环境",-1),a("p",null,"jvm：java虚拟机",-1),a("h3",{id:"_3、构造方法",tabindex:"-1"},[l("3、构造方法 "),a("a",{class:"header-anchor",href:"#_3、构造方法","aria-label":'Permalink to "3、构造方法"'},"​")],-1),a("h4",{id:"特性",tabindex:"-1"},[l("特性 "),a("a",{class:"header-anchor",href:"#特性","aria-label":'Permalink to "特性"'},"​")],-1),a("p",null,"和类名相同、可以对一些属性、方法进行初始化",-1),a("p",null,"自动执行、无需调用 没有返回值",-1),a("h4",{id:"定义无参构造的作用",tabindex:"-1"},[l("定义无参构造的作用 "),a("a",{class:"header-anchor",href:"#定义无参构造的作用","aria-label":'Permalink to "定义无参构造的作用"'},"​")],-1),a("p",null,"如果子类没有调用父类的构造方法，默认调用无参构造",-1),a("h3",{id:"_4、java中创建对象的方法",tabindex:"-1"},[l("4、java中创建对象的方法 "),a("a",{class:"header-anchor",href:"#_4、java中创建对象的方法","aria-label":'Permalink to "4、java中创建对象的方法"'},"​")],-1),a("p",null,"1、new关键字",-1),a("p",null,"2、反射 class.forName.newInstance()",-1),a("p",null,"3、clone()方法",-1),a("h3",{id:"_5、final、finally、finalize的区别",tabindex:"-1"},[l("5、final、finally、finalize的区别 "),a("a",{class:"header-anchor",href:"#_5、final、finally、finalize的区别","aria-label":'Permalink to "5、final、finally、finalize的区别"'},"​")],-1),a("p",null,"final：申明属性不可以被修改、方法不可以被重写、类不能被继承",-1),a("p",null,"finally：异常处理语句的一部分",-1),a("p",null,"finallize：object类的方法，垃圾回收的时候会调用被回收对象的finalize",-1),a("h3",{id:"_6、-和-区别",tabindex:"-1"},[l("6、&和&&区别 "),a("a",{class:"header-anchor",href:"#_6、-和-区别","aria-label":'Permalink to "6、&和&&区别"'},"​")],-1),a("p",null,"都是表示逻辑与的运算符",-1),a("p",null,"&& 短路功能 &没有",-1),a("p",null,"&可以作为位运算符",-1),a("h3",{id:"_7、java中参数传递值还是引用",tabindex:"-1"},[l("7、java中参数传递值还是引用 "),a("a",{class:"header-anchor",href:"#_7、java中参数传递值还是引用","aria-label":'Permalink to "7、java中参数传递值还是引用"'},"​")],-1),a("p",null,"Java 的参数是以值传递的形式传⼊⽅法中，⽽不是引⽤传递。",-1),a("p",null,"当传递⽅法参数类型为基本数据类型（数字以及布尔值）时，⼀个⽅法是不可能修改⼀个基本数据类型的参数。",-1),a("p",null,"当传递⽅法参数类型为引⽤数据类型时，⼀个⽅法将修改⼀个引⽤数据类型的参数所指向对象的值。即使 Java 函数在传递引⽤数据类型时，也只是拷⻉了引⽤的值罢了，之所以能修改引⽤数据是因为它们同时指向了⼀个对象，但这仍然是按值调⽤⽽不是引⽤调⽤",-1),a("p",null,"简单来说，方法参数传递的时候：",-1),a("p",null,"基本数据类型，传递的是数据值",-1),a("p",null,"引用数据类型，传递的是地址值",-1),a("p",null,"所以是值传递，地址值也是值",-1),a("h3",{id:"_8、如何实现对象的拷贝",tabindex:"-1"},[l("8、如何实现对象的拷贝 "),a("a",{class:"header-anchor",href:"#_8、如何实现对象的拷贝","aria-label":'Permalink to "8、如何实现对象的拷贝"'},"​")],-1),a("p",null,"1、实现 Cloneable 接⼝并重写 Object 类中的 clone() ⽅法；",-1),a("p",null,"2、实现 Serializable 接⼝，通过对象的序列化和反序列化实现克隆，可以实现真正的深克隆。",-1),a("h4",{id:"浅拷贝和深拷贝区别",tabindex:"-1"},[l("浅拷贝和深拷贝区别 "),a("a",{class:"header-anchor",href:"#浅拷贝和深拷贝区别","aria-label":'Permalink to "浅拷贝和深拷贝区别"'},"​")],-1),a("p",null,"浅拷贝：只是复制了原对象的地址，任何一个值改变，其余的都会改变",-1),a("p",null,"深拷贝：拷贝对象和原对象的地址不同",-1),a("h3",{id:"_9、对象的创建过程",tabindex:"-1"},[l("9、对象的创建过程 "),a("a",{class:"header-anchor",href:"#_9、对象的创建过程","aria-label":'Permalink to "9、对象的创建过程"'},"​")],-1),a("p",null,"对象被实例化之前，jvm会检查是否该对象已经被加载并初始化。",-1),a("p",null,"没有的话，需要立即去加载目标类，然后调用目标类的构造函数完成初始化。",-1),a("p",null,"（对静态变量、成员变量、静态代码块等进行初始化）",-1),a("p",null,"初始化完成，根据对象的大小分配内存空间，然后调用init方法",-1),a("h3",{id:"_10、java有没有指针",tabindex:"-1"},[l("10、java有没有指针 "),a("a",{class:"header-anchor",href:"#_10、java有没有指针","aria-label":'Permalink to "10、java有没有指针"'},"​")],-1),a("p",null,"没有指针，对象和数组通过引用来处理。",-1),a("p",null,"垃圾回收器自动管理对象和数组的内存分配和释放，所有的对象都是通过引用来进行传递的",-1),a("p",null,"通过new创建一个新的对象或数组，并将其赋值给引用变量。",-1),a("h3",{id:"_11、修饰符",tabindex:"-1"},[l("11、修饰符 "),a("a",{class:"header-anchor",href:"#_11、修饰符","aria-label":'Permalink to "11、修饰符"'},"​")],-1),a("p",null,"public：（任意位置）被修饰的对象或者变量 任何地方都是可见的",-1),a("p",null,"protected：（同一个类，同一个包，不同包的子类）对于不同包的类，只有继承该类才能访问",-1),a("p",null,"default：（同一个类，同一个包）",-1),a("p",null,"private：（同一个类中）",-1),a("h4",{id:"常量的修饰",tabindex:"-1"},[l("常量的修饰 "),a("a",{class:"header-anchor",href:"#常量的修饰","aria-label":'Permalink to "常量的修饰"'},"​")],-1),a("p",null,"public static final一起修饰",-1),a("h3",{id:"_12、序列化和反序列化",tabindex:"-1"},[l("12、序列化和反序列化 "),a("a",{class:"header-anchor",href:"#_12、序列化和反序列化","aria-label":'Permalink to "12、序列化和反序列化"'},"​")],-1),a("h4",{id:"概念",tabindex:"-1"},[l("概念 "),a("a",{class:"header-anchor",href:"#概念","aria-label":'Permalink to "概念"'},"​")],-1),a("p",null,"序列化是将对象转化为字节流的过程，可以保存到磁盘或者通过网络进行传输",-1),a("p",null,"从字节流创建对象称为反序列化",-1),a("h4",{id:"目的",tabindex:"-1"},[l("目的 "),a("a",{class:"header-anchor",href:"#目的","aria-label":'Permalink to "目的"'},"​")],-1),a("p",null,"解决网络通信中对象传输的问题。前提要保证传输的可识别性，将对象先转化为通用的解析格式（比如json、xml等格式），再转化为数据流进行网络传输。",-1),a("h4",{id:"实现",tabindex:"-1"},[l("实现 "),a("a",{class:"header-anchor",href:"#实现","aria-label":'Permalink to "实现"'},"​")],-1),a("p",null,"被序列化的对象需要实现serializable接口",-1),a("p",null,"使⽤⼀个输出流（如：FileOutputStream）来构造⼀个 ObjectOutputStream 对象",-1),a("p",null,"使⽤ ObjectOutputStream 对象的 writeObject(Object obj) ⽅法可以将参数为 obj 的对象写出，要恢复的话则使⽤输⼊流。",-1),a("h4",{id:"使用情形",tabindex:"-1"},[l("使用情形 "),a("a",{class:"header-anchor",href:"#使用情形","aria-label":'Permalink to "使用情形"'},"​")],-1),a("p",null,"把对象状态保存到一个文件或者数据库中，用套接字在网络上传送对象",-1),a("h3",{id:"_13、java跨平台",tabindex:"-1"},[l("13、java跨平台 "),a("a",{class:"header-anchor",href:"#_13、java跨平台","aria-label":'Permalink to "13、java跨平台"'},"​")],-1),a("p",null,"运行java程序的操作系统上，有与操作系统对应的虚拟机",-1),a("p",null,"jvm虚拟机不能跨平台，允许跨平台的是java程序",-1),a("h3",{id:"_14、static关键字的作用",tabindex:"-1"},[l("14、static关键字的作用 "),a("a",{class:"header-anchor",href:"#_14、static关键字的作用","aria-label":'Permalink to "14、static关键字的作用"'},"​")],-1),a("p",null,"可以修饰普通变量和普通函数，也可以修饰成员变量和成员函数",-1),a("p",null,"修饰普通变量和普通函数的时候，只在本源文件中可见，且修饰普通变量时，默认初始化的值为0",-1),a("p",null,"修饰成员函数和成员变量的时候，一个类只有这一份，不需要生成对象就可以访问该成员，所有成员共享这一份变量",-1),a("p",null,"static关键字用于表示静态成员，用于变量、方法和代码块",-1),a("h4",{id:"静态变量",tabindex:"-1"},[l("静态变量 "),a("a",{class:"header-anchor",href:"#静态变量","aria-label":'Permalink to "静态变量"'},"​")],-1),a("p",null,"属于类，不属于类的实例。在类加载的时候被初始化，所有的实例共享同一个变量的值",-1),a("h4",{id:"静态方法",tabindex:"-1"},[l("静态方法 "),a("a",{class:"header-anchor",href:"#静态方法","aria-label":'Permalink to "静态方法"'},"​")],-1),a("p",null,"属于类，不属于类的实例。可以直接通过类名调用静态方法，无需创建类的实例。",-1),a("p",null,"静态方法不能访问非静态的成员变量和方法",-1),a("h4",{id:"静态代码块",tabindex:"-1"},[l("静态代码块 "),a("a",{class:"header-anchor",href:"#静态代码块","aria-label":'Permalink to "静态代码块"'},"​")],-1),a("p",null,"类加载时执行一段代码。在类的静态变量初始化之前执行，并且只执行一次",-1),a("p",null,"通常用于进行类的初始化操作",-1),a("h4",{id:"static类和普通类的区别",tabindex:"-1"},[l("static类和普通类的区别 "),a("a",{class:"header-anchor",href:"#static类和普通类的区别","aria-label":'Permalink to "static类和普通类的区别"'},"​")],-1),a("p",null,"1、static类可以在没有外部类实例的情况下被实例化，普通类必须被实例化才能使用",-1),a("p",null,"2、静态嵌套类不能直接访问包含它的外部类的非晶态成员。普通类可以访问它所在的外部类的所有成员，包括非静态成员",-1),a("p",null,"3、静态嵌套类可以包含静态成员，普通类也可以包含静态成员",-1),a("p",null,"4、静态嵌套类被定义在包含它的外部类的作用域内，但并不是外部类的成员。普通类一般是独立定义的",-1),a("h3",{id:"_15、环境变量path",tabindex:"-1"},[l("15、环境变量path "),a("a",{class:"header-anchor",href:"#_15、环境变量path","aria-label":'Permalink to "15、环境变量path"'},"​")],-1),a("p",null,"当我们运行一个程序，但是没有告诉系统完整路径的时候，除了在当前目录，还会在path指定的路径中去查找，简化启动程序的命令",-1),a("h3",{id:"_16、多态性和虚函数",tabindex:"-1"},[l("16、多态性和虚函数 "),a("a",{class:"header-anchor",href:"#_16、多态性和虚函数","aria-label":'Permalink to "16、多态性和虚函数"'},"​")],-1),a("h4",{id:"多态性",tabindex:"-1"},[l("多态性 "),a("a",{class:"header-anchor",href:"#多态性","aria-label":'Permalink to "多态性"'},"​")],-1),a("p",null,"同一个方法或操作可以在不同的对象上具有不同的行为。通过继承和方法重写实现",-1),a("h4",{id:"虚函数",tabindex:"-1"},[l("虚函数 "),a("a",{class:"header-anchor",href:"#虚函数","aria-label":'Permalink to "虚函数"'},"​")],-1),a("p",null,"所有的非静态方法默认都是虚函数",-1),a("h1",{id:"集合、数据类型",tabindex:"-1"},[l("集合、数据类型 "),a("a",{class:"header-anchor",href:"#集合、数据类型","aria-label":'Permalink to "集合、数据类型"'},"​")],-1),a("h3",{id:"_1、数据类型、包装类",tabindex:"-1"},[l("1、数据类型、包装类 "),a("a",{class:"header-anchor",href:"#_1、数据类型、包装类","aria-label":'Permalink to "1、数据类型、包装类"'},"​")],-1),a("h4",{id:"基本数据类型",tabindex:"-1"},[l("基本数据类型 "),a("a",{class:"header-anchor",href:"#基本数据类型","aria-label":'Permalink to "基本数据类型"'},"​")],-1),a("p",null,"byte 1 short 2 int 4 long 8",-1),a("p",null,"Float 4 double 8 boolean 1 char 2",-1),a("p",null,"都有对应包装类",-1),a("h4",{id:"引用数据类型",tabindex:"-1"},[l("引用数据类型 "),a("a",{class:"header-anchor",href:"#引用数据类型","aria-label":'Permalink to "引用数据类型"'},"​")],-1),a("p",null,"String Array set list",-1),a("h4",{id:"空类型",tabindex:"-1"},[l("空类型 "),a("a",{class:"header-anchor",href:"#空类型","aria-label":'Permalink to "空类型"'},"​")],-1),a("p",null,"不返回任何值",-1),a("h4",{id:"默认值",tabindex:"-1"},[l("默认值 "),a("a",{class:"header-anchor",href:"#默认值","aria-label":'Permalink to "默认值"'},"​")],-1),a("p",null,"0 Null",-1),a("h4",{id:"包装类作用",tabindex:"-1"},[l("包装类作用 "),a("a",{class:"header-anchor",href:"#包装类作用","aria-label":'Permalink to "包装类作用"'},"​")],-1),a("p",null,"转化为对象，提供属性和方法，有一些静态方法可以操作",-1),a("p",null,"供集合类和泛型使用，集合类中操作元素，是以对象为基础的",-1),a("p",null,"包装类的父类是number类，是所有数值型包装类的父类",-1),a("h4",{id:"装箱和拆箱",tabindex:"-1"},[l("装箱和拆箱 "),a("a",{class:"header-anchor",href:"#装箱和拆箱","aria-label":'Permalink to "装箱和拆箱"'},"​")],-1),a("p",null,"基本数据类型和包装类型之间的转化",-1),a("h4",{id:"int和integer的区别",tabindex:"-1"},[l("int和integer的区别 "),a("a",{class:"header-anchor",href:"#int和integer的区别","aria-label":'Permalink to "int和integer的区别"'},"​")],-1),a("p",null,"作为成员变量，int初始值为0，integer初始值为null",-1),a("p",null,"integer存储在堆内存，int直接存储在栈空间",-1),a("h4",{id:"隐式转换",tabindex:"-1"},[l("隐式转换 "),a("a",{class:"header-anchor",href:"#隐式转换","aria-label":'Permalink to "隐式转换"'},"​")],-1),a("p",null,"基本隐式转换：把一个取值范围小的数值或变量，赋值给一个取值范围大的变量",-1),a("p",null,"运算中的隐式转换：byte short char 三种数据运算的时候 都会提升为int 然后再进行运算",-1),a("h4",{id:"强制转换",tabindex:"-1"},[l("强制转换 "),a("a",{class:"header-anchor",href:"#强制转换","aria-label":'Permalink to "强制转换"'},"​")],-1),a("p",null,"把取值范围大的数值或变量，赋值给另一个取值范围小的变量",-1),a("p",null,"不允许直接赋值，需要加入强制转换",-1),a("p",null,"有可能会出现精度损失",-1),a("p",null,"扩展赋值运算符，内部自带强转效果",-1),a("p",null,"short s=1;",-1),a("p",null,"s=s+1;",-1),a("h3",{id:"_2、equals和",tabindex:"-1"},[l("2、equals和== "),a("a",{class:"header-anchor",href:"#_2、equals和","aria-label":'Permalink to "2、equals和=="'},"​")],-1),a("h4",{id:"区别-1",tabindex:"-1"},[l("区别 "),a("a",{class:"header-anchor",href:"#区别-1","aria-label":'Permalink to "区别"'},"​")],-1),a("p",null,"基本数据类型",-1),a("p",null,"== 比较数值",-1),a("p",null,"equals不能用于基本数据类型的比较",-1),a("p",null,"引用数据类型",-1),a("p",null,"== 比较地址值是否相同",-1),a("p",null,"equals 比较对象内容是否相同",-1),a("h4",{id:"如何重写equals",tabindex:"-1"},[l("如何重写equals "),a("a",{class:"header-anchor",href:"#如何重写equals","aria-label":'Permalink to "如何重写equals"'},"​")],-1),a("p",null,"如果对象是自己，返回true",-1),a("p",null,"如果对象为null或者不是同一类型，返回false",-1),a("p",null,"重写需要相同的类型的相等条件",-1),a("p",null,"如果要操作集合类hashmap，必须要重写hashcode",-1),a("p",null,"（使用hashcode的好处：equals对于大量数据比较过于繁琐，使用hashcode可以快速定位位置，大大减少了开销）",-1),a("p",null,"规定：两个对象相等，hashcode一定相同，调用equals方法都返回true",-1),a("h3",{id:"_3、抽象类和接口的区别",tabindex:"-1"},[l("3、抽象类和接口的区别 "),a("a",{class:"header-anchor",href:"#_3、抽象类和接口的区别","aria-label":'Permalink to "3、抽象类和接口的区别"'},"​")],-1),a("p",null,"成员权限、抽象方法、静态方法",-1),a("p",null,"抽象类：",-1),a("p",null,"定义方式：abstract class",-1),a("p",null,"可以有抽象方法和具体方法，能定义构造函数",-1),a("p",null,"成员权限：public default protected",-1),a("p",null,"可以包含静态方法",-1),a("p",null,"接口：",-1),a("p",null,"定义方式：interface",-1),a("p",null,"只有抽象方法",-1),a("p",null,"成员权限：public",-1),a("p",null,"没有具体的方法，不能定义构造函数",-1),a("p",null,"实现需要在对应实现类中，没有具体的方法体",-1),a("p",null,"不可以包含静态方法",-1),a("h3",{id:"_4、变量",tabindex:"-1"},[l("4、变量 "),a("a",{class:"header-anchor",href:"#_4、变量","aria-label":'Permalink to "4、变量"'},"​")],-1),a("h4",{id:"静态变量和实例变量-区别",tabindex:"-1"},[l("静态变量和实例变量 区别 "),a("a",{class:"header-anchor",href:"#静态变量和实例变量-区别","aria-label":'Permalink to "静态变量和实例变量 区别"'},"​")],-1),a("p",null,"静态变量：被static修饰的变量 仅有一份拷贝",-1),a("p",null,"实例变量：先创建对象，才能访问，属于某一实例",-1),a("h4",{id:"this-关键字",tabindex:"-1"},[l("This 关键字 "),a("a",{class:"header-anchor",href:"#this-关键字","aria-label":'Permalink to "This 关键字"'},"​")],-1),a("p",null,"区分局部变量和成员变量",-1),a("h4",{id:"lambda表达式",tabindex:"-1"},[l("lambda表达式 "),a("a",{class:"header-anchor",href:"#lambda表达式","aria-label":'Permalink to "lambda表达式"'},"​")],-1),a("p",null,"简化匿名内部类的写法，只能简化函数式接口",-1),a("p",null,"抽象类是不能用lambda表达式进行改写的",-1),a("p",{方法体:""},"语法 (参数列表)->",-1),a("h3",{id:"_5、object类的常用方法",tabindex:"-1"},[l("5、object类的常用方法 "),a("a",{class:"header-anchor",href:"#_5、object类的常用方法","aria-label":'Permalink to "5、object类的常用方法"'},"​")],-1),a("p",null,"clone：创建当前对象的拷贝",-1),a("p",null,"getClass：返回当前运行时对象的class",-1),a("p",null,"toString：转化为字符串",-1),a("p",null,"equals：比较两个对象的内存地址是否相等",-1),a("p",null,"hashCode：返回哈希值",-1),a("h3",{id:"_6、遍历数组的方法",tabindex:"-1"},[l("6、遍历数组的方法 "),a("a",{class:"header-anchor",href:"#_6、遍历数组的方法","aria-label":'Permalink to "6、遍历数组的方法"'},"​")],-1),a("p",null,"for循环遍历",-1),a("p",null,"for each遍历",-1),a("p",null,"迭代器遍历",-1),a("h4",{id:"数组初始化",tabindex:"-1"},[l("数组初始化 "),a("a",{class:"header-anchor",href:"#数组初始化","aria-label":'Permalink to "数组初始化"'},"​")],-1),a("p",null,"动态初始化：手动指定长度，系统分配默认初始化值",-1),a("p",null,"静态初始化：手动指定元素，系统根据元素个数，计算出数组的长度",-1),a("h3",{id:"_7、java中参数传递值还是传引用",tabindex:"-1"},[l("7、java中参数传递值还是传引用 "),a("a",{class:"header-anchor",href:"#_7、java中参数传递值还是传引用","aria-label":'Permalink to "7、java中参数传递值还是传引用"'},"​")],-1),a("p",null,"传递值",-1),a("p",null,"传递方法类型为基本数据类型，方法不可能修改一个基本数据类型的参数",-1),a("p",null,"传递方法类型为引用数据类型，方法将修改一个引用参数类型参数指向对象的值",-1),a("p",null,"方法参数传递的时候：",-1),a("p",null,"基本数据类型，传递的是数据值",-1),a("p",null,"引用数据类型，传递的是地址值",-1),a("p",null,"值传递，地址值也是值",-1),a("h3",{id:"_8、集合框架collection、map",tabindex:"-1"},[l("8、集合框架Collection、map "),a("a",{class:"header-anchor",href:"#_8、集合框架collection、map","aria-label":'Permalink to "8、集合框架Collection、map"'},"​")],-1),a("h4",{id:"collection包含set、list、queue-collection接口保存数据的目的主要是输出",tabindex:"-1"},[l("Collection包含set、list、queue，collection接口保存数据的目的主要是输出 "),a("a",{class:"header-anchor",href:"#collection包含set、list、queue-collection接口保存数据的目的主要是输出","aria-label":'Permalink to "Collection包含set、list、queue，collection接口保存数据的目的主要是输出"'},"​")],-1),a("p",null,"是最基本的集合接⼝，⼀个 Collection 代表⼀组 Object，即 Collection 的元素。它的直接继承接⼝有List，Set 和 Queue。",-1),a("h4",{id:"set-不允许重复元素存在",tabindex:"-1"},[l("set-不允许重复元素存在 "),a("a",{class:"header-anchor",href:"#set-不允许重复元素存在","aria-label":'Permalink to "set-不允许重复元素存在"'},"​")],-1),a("p",null,"1、hashset：底层hashmap，hashset的值是作为hashmap中的key存储在hashmap中的",-1),a("p",null,"2、treeset：底层红黑树",-1),a("p",null,"3、sortedSet->linkedhashset：通过linkedhashmap实现",-1),a("h4",{id:"list-有序集合-允许重复元素存在",tabindex:"-1"},[l("list-有序集合，允许重复元素存在 "),a("a",{class:"header-anchor",href:"#list-有序集合-允许重复元素存在","aria-label":'Permalink to "list-有序集合，允许重复元素存在"'},"​")],-1),a("p",null,"1、arraylist：底层是动态数组，查找快，添加慢。初始容量为10（指添加元素后，添加元素之前是空数组） 每次扩容后，容量为之前的1.5倍，旧的数组将被回收",-1),a("p",null,"arraylist可以添加任意数据类型，但通常限定",-1),a("p",null,"list.add()方法返回值一定为true",-1),a("p",null,"2、linkedlist：底层是双向链表，不能根据索引查找",-1),a("p",null,"3、vector->stack：vector基于数组实现的动态数组。内部使用一个对象数组来存储元素，并支持自动扩容，扩容增加一倍的容量",-1),a("p",null,"arraylist和linkedlist线程不安全，但是vector线程是安全的（加了synchronized锁），所以vector性能较低",-1),a("h4",{id:"queue",tabindex:"-1"},[l("queue "),a("a",{class:"header-anchor",href:"#queue","aria-label":'Permalink to "queue"'},"​")],-1),a("p",null,"1、deque->arraydeque 双端队列",-1),a("h4",{id:"map的子类有hashmap、hashtable、concurrenthashmap、treemap、linkedhashmap",tabindex:"-1"},[l("map的子类有hashmap、hashtable、concurrentHashMap、Treemap、linkedhashmap "),a("a",{class:"header-anchor",href:"#map的子类有hashmap、hashtable、concurrenthashmap、treemap、linkedhashmap","aria-label":'Permalink to "map的子类有hashmap、hashtable、concurrentHashMap、Treemap、linkedhashmap"'},"​")],-1),a("p",null,"1、hashmap：基于哈希表实现，无序存放，key或者value可以保存为null",-1),a("p",null,"Jdk8 使用链表+红黑树解决冲突问题（哈希冲突：多个键映射到同一个位置）",-1),a("p",null,"底层原理：",-1),a("p",null,"初始容量是16",-1),a("p",null,"使用哈希表存储数据（数组），将一个键值对存储到hashmap中时，首先使用哈希函数对键进行哈希计算，得到一个哈希值。将键映射到哈希表的索引位置上。",-1),a("p",null,"冲突处理：哈希函数计算结果可能会导致不同的键映射到相同的索引位置。当多个键值对映射到同一个位置上时，通过链表或红黑树存储",-1),a("p",null,"当链表上的元素个数超过 8 个并且数组⻓度 >= 64 时⾃动转化成红⿊树，节点变成树节点，以提⾼搜索效率和插⼊效率到 O(logN)。",-1),a("p",null,"扩容：达到阈值时，hashmap会创建一个新的哈希表，大小是原来的两倍，并将原哈希表中的所有元素重信哈希到哈希表中",-1),a("p",null,"使用场景：高效的插入、删除、查找操作，不考虑元素的排序顺序",-1),a("p",null,"不需要按照特定的顺序遍历元素",-1),a("p",null,"2、hashtable：key不能设置为null。线程安全",-1),a("p",null,"使用synchronized关键字对整个表进行加锁，效率低",-1),a("p",null,"3、treemap：基于红黑树实现，可以按照key排序，key不能重复。不允许null键，允许null值",-1),a("p",null,"使用场景：需要获取某个范围的键或值",-1),a("p",null,"4、concurrenthashmap：基于分段锁实现（segment）的哈希表，将整个hashmap分成多段，每个段拥有自己的锁，可以支持多线程并发访问，提高并发性能",-1),a("p",null,"可以实现多线程的put操作",-1),a("p",null,"JDK 7：中 ConcurrentHashMap 采⽤了数组 + Segment + 分段锁的⽅式实现。",-1),a("p",null,"JDK 8：中 ConcurrentHashMap 参考了 JDK 8 HashMap 的实现，采⽤了数组 + 链表 + 红⿊树的实现⽅式来设计，内部⼤量采⽤ CAS 操作。",-1),a("p",null,"5、linkedhashmap：基于哈希表和双向链表实现，哈希表实现元素的存储和查找，双向链表实现插入和访问顺序。允许null键和null值",-1),a("h4",{id:"关联容器-存储和管理键值对的数据结构",tabindex:"-1"},[l("关联容器：存储和管理键值对的数据结构 "),a("a",{class:"header-anchor",href:"#关联容器-存储和管理键值对的数据结构","aria-label":'Permalink to "关联容器：存储和管理键值对的数据结构"'},"​")],-1),a("h4",{id:"arraylist和linkedlist增删查速度比较",tabindex:"-1"},[l("arraylist和linkedlist增删查速度比较 "),a("a",{class:"header-anchor",href:"#arraylist和linkedlist增删查速度比较","aria-label":'Permalink to "arraylist和linkedlist增删查速度比较"'},"​")],-1),a("p",null,"1、如果是在末尾，arraylist不需要移动和复制数组来进行操作。如果数据量有百万级，比linkedlist快",-1),a("p",null,"2、如果是在中间，数据量有百万级，还是arraylist快",-1),a("p",null,"linkedlist的消耗主要在遍历上，arraylist的消耗主要在移动和复制上，linkedlist遍历速度慢于arraylist的复制",-1),a("h4",{id:"array和arryalist的区别",tabindex:"-1"},[l("array和arryalist的区别 "),a("a",{class:"header-anchor",href:"#array和arryalist的区别","aria-label":'Permalink to "array和arryalist的区别"'},"​")],-1),a("ol",null,[a("li",null,[a("p",null,"Array 可以容纳基本类型和对象，⽽ ArrayList 只能容纳对象；")]),a("li",null,[a("p",null,"Array 是指定⼤⼩的，⽽ ArrayList ⼤⼩是固定的。")]),a("li",null,[a("p",null,"如果列表的⼤⼩已经指定，⼤部分情况下是存储和遍历它们；")]),a("li",null,[a("p",null,"对于遍历基本数据类型，尽管 Collections 使⽤⾃动装箱来减轻编码任务，在指定⼤⼩的基本类型的列表上⼯作也会变得很慢；")]),a("li",null,[a("p",null,"如果你要使⽤多维数组，使⽤array比list更容易")])],-1),a("h3",{id:"_9、string类",tabindex:"-1"},[l("9、String类 "),a("a",{class:"header-anchor",href:"#_9、string类","aria-label":'Permalink to "9、String类"'},"​")],-1),a("h4",{id:"设计为不可变类",tabindex:"-1"},[l("设计为不可变类 "),a("a",{class:"header-anchor",href:"#设计为不可变类","aria-label":'Permalink to "设计为不可变类"'},"​")],-1),a("p",null,"String类为引用类型，不可变，提高字符串的安全性、性能上优化",-1),a("p",null,"安全性：不能被修改，避免多线程环境下并发访问问题",-1),a("p",null,"缓存和性能优化：先去检查字符串常量池中是否有该字符串相同的值，存在的话，就返回常量池中的引用，避免重复创建相同值的字符串对象，节省了内存空间",-1),a("p",null,"允许String对象缓存hashcode：java中String对象的哈希码被频繁使用，比如在hashmap等容器中",-1),a("p",null,"被许多java类库用来当作参数：网络连接地址url、文件路径path，如果不是固定不变的，将会引起各种安全隐患。",-1),a("h4",{id:"string、stringbuilder、stringbuffer区别",tabindex:"-1"},[l("string、stringbuilder、stringbuffer区别 "),a("a",{class:"header-anchor",href:"#string、stringbuilder、stringbuffer区别","aria-label":'Permalink to "string、stringbuilder、stringbuffer区别"'},"​")],-1),a("p",null,"string：用于字符串操作，属于不可变类，每次对string操作都会创建一个新的对象",-1),a("p",null,"stringbuilder：线程不安全的可变字符串序列，可以提高字符串的操作效率，可以存储任意数据类型，但是进入这个容器，全部变成字符串",-1),a("p",null,"StringBuffer：也⽤于字符串操作，不同之处是 StringBuffer 属于可变类，对⽅法加了同步锁，线程安全",-1),a("h4",{id:"string常用方法",tabindex:"-1"},[l("string常用方法 "),a("a",{class:"header-anchor",href:"#string常用方法","aria-label":'Permalink to "string常用方法"'},"​")],-1),a("p",null,"indexOf()：返回指定字符的索引。",-1),a("p",null,"charAt()：返回指定索引处的字符。",-1),a("p",null,"replace()：字符串替换。",-1),a("p",null,"trim()：去除字符串两端空⽩。",-1),a("p",null,"split()：分割字符串，返回⼀个分割后的字符串数组。",-1),a("p",null,"getBytes()：返回字符串的 byte 类型数组。",-1),a("p",null,"length()：返回字符串⻓度。",-1),a("p",null,"toLowerCase()：将字符串转成⼩写字⺟。",-1),a("p",null,"toUpperCase()：将字符串转成⼤写字符。",-1),a("p",null,"substring()：截取字符串。",-1),a("p",null,"equals()：字符串⽐较",-1),a("h4",{id:"修改字符串的几种方式",tabindex:"-1"},[l("修改字符串的几种方式 "),a("a",{class:"header-anchor",href:"#修改字符串的几种方式","aria-label":'Permalink to "修改字符串的几种方式"'},"​")],-1),a("p",null,"1、使用string类中的replace方法，该方法将字符串中某个字符或或字符串替换，并返回一个新的字符串对象",-1),a("p",null,"2、使用stringbuilder类，它们提供了修改字符串的方法，例如append() insert() replace() 等 通过这些方法可以对字符串进行修改，并返回一个新的stringbuilder对象，然后使用toString 返回",-1),a("p",null,"3、使用字符数组char[]",-1),a("h3",{id:"_10、数组和链表的使用场景和优缺点",tabindex:"-1"},[l("10、数组和链表的使用场景和优缺点 "),a("a",{class:"header-anchor",href:"#_10、数组和链表的使用场景和优缺点","aria-label":'Permalink to "10、数组和链表的使用场景和优缺点"'},"​")],-1),a("p",null,"数组是线性数据结构，可以在内存中连续存储多个相同类型的元素。访问元素的时间复杂度为O(1)内存分配连续，空间上相对紧凑，对大量元素的存储比较节省内存。",-1),a("p",null,"链表是非连续的数据结构，由一系列节点组成，每个节点包含一个数据元素和一个指向下一个节点的引用。可以动态地插入和删除元素。大小可以动态调整，不受固定大小的限制。",-1),a("h3",{id:"_11、collections",tabindex:"-1"},[l("11、collections "),a("a",{class:"header-anchor",href:"#_11、collections","aria-label":'Permalink to "11、collections"'},"​")],-1),a("p",null,"不属于java的集合框架，是集合类的一个工具类。包含有关集合操作的静态多态方法，实现对各种集合的搜索、排序、线程安全等操作",-1),a("h3",{id:"_12、如何设计消息队列",tabindex:"-1"},[l("12、如何设计消息队列 "),a("a",{class:"header-anchor",href:"#_12、如何设计消息队列","aria-label":'Permalink to "12、如何设计消息队列"'},"​")],-1),a("p",null,"可以使用queue集合类来实现消息队列",-1),a("p",null,"可以使用线程安全的队列Concurrentlinkedqueue",-1),a("p",null,"使用cas操作进行插入和删除，不需要锁",-1),a("h3",{id:"_13、jdk并发容器",tabindex:"-1"},[l("13、jdk并发容器 "),a("a",{class:"header-anchor",href:"#_13、jdk并发容器","aria-label":'Permalink to "13、jdk并发容器"'},"​")],-1),a("ol",null,[a("li",null,"ConcurrentHashMap：线程安全的 HashMap；"),a("li",null,"CopyOnWriteArrayList：线程安全的 List，在读多写少的场合性能⾮常好，远远好于 Vector；"),a("li",null,"ConcurrentLinkedQueue：⾼效的并发队列，使⽤链表实现。可以看做⼀个线程安全的 LinkedList，这是⼀")],-1),a("p",null,"个⾮阻塞队列；",-1),a("ol",{start:"4"},[a("li",null,"BlockingQueue：这是⼀个接⼝，JDK 内部通过链表、数组等⽅式实现了这个接⼝。表示阻塞队列，⾮常适合")],-1),a("p",null,"⽤于作为数据共享的通道；",-1),a("ol",{start:"5"},[a("li",null,"ConcurrentSkipListMap：跳表的实现。这是⼀个 Map，使⽤跳表的数据结构进⾏快速查找。")],-1),a("h3",{id:"_14、hashmap一系列问题",tabindex:"-1"},[l("14、hashmap一系列问题 "),a("a",{class:"header-anchor",href:"#_14、hashmap一系列问题","aria-label":'Permalink to "14、hashmap一系列问题"'},"​")],-1),a("h4",{id:"原理",tabindex:"-1"},[l("原理 "),a("a",{class:"header-anchor",href:"#原理","aria-label":'Permalink to "原理"'},"​")],-1),a("p",null,"基于哈希表实现，无序存放，key或者value可以保存为null，初始容量是16",-1),a("p",null,"Jdk8 使用链表+红黑树解决冲突问题（哈希冲突：多个键映射到同一个位置）",-1),a("p",null,"使用哈希表存储数据（数组），将一个键值对存储到hashmap中时，首先使用哈希函数对键进行哈希计算，得到一个哈希值。将键映射到哈希表的索引位置上。",-1),a("h4",{id:"冲突处理",tabindex:"-1"},[l("冲突处理 "),a("a",{class:"header-anchor",href:"#冲突处理","aria-label":'Permalink to "冲突处理"'},"​")],-1),a("p",null,"哈希函数计算结果可能会导致不同的键映射到相同的索引位置。当多个键值对映射到同一个位置上时，通过链表或红黑树存储",-1),a("p",null,"当链表上的元素个数超过 8 个并且数组⻓度 >= 64 时⾃动转化成红⿊树，节点变成树节点，以提⾼搜索效率和插⼊效率到 O(logN)。",-1),a("h4",{id:"扩容",tabindex:"-1"},[l("扩容 "),a("a",{class:"header-anchor",href:"#扩容","aria-label":'Permalink to "扩容"'},"​")],-1),a("p",null,"默认装载因子是0.75。达到阈值时，hashmap会创建一个新的哈希表，大小是原来的两倍，并将原哈希表中的所有元素重信哈希到哈希表中",-1),a("h4",{id:"put方法执行过程",tabindex:"-1"},[l("Put方法执行过程 "),a("a",{class:"header-anchor",href:"#put方法执行过程","aria-label":'Permalink to "Put方法执行过程"'},"​")],-1),a("p",null,"添加键值对时，先计算key的hash值进行映射到hashmap中的位置。没有元素，则直接插入；有的话，迭代该处元素链表并依次比较其key的hash值。有相等的则覆盖原来的value",-1),a("h4",{id:"get方法执行过程",tabindex:"-1"},[l("get方法执行过程 "),a("a",{class:"header-anchor",href:"#get方法执行过程","aria-label":'Permalink to "get方法执行过程"'},"​")],-1),a("p",null,"通过key的hash值找到在数组中的索引处的entry，然后返回该key对应的value",-1),a("h4",{id:"get方法不能判断某个元素在map中",tabindex:"-1"},[l("get方法不能判断某个元素在map中 "),a("a",{class:"header-anchor",href:"#get方法不能判断某个元素在map中","aria-label":'Permalink to "get方法不能判断某个元素在map中"'},"​")],-1),a("p",null,"HashMap 的 get 函数的返回值不能判断⼀个 key 是否包含在 map 中，因为 get 返回 null 有可能是不包含该key，也有可能该 key 对应的 value 为 null。因为 HashMap 中允许 key 为 null，也允许 value 为 null。",-1),a("h4",{id:"死循环问题",tabindex:"-1"},[l("死循环问题 "),a("a",{class:"header-anchor",href:"#死循环问题","aria-label":'Permalink to "死循环问题"'},"​")],-1),a("p",null,"主要是多线程同时 put 时，如果同时触发了 rehash 操作，会导致 HashMap 中的链表中出现循环节点，进⽽使得后⾯ get 的时候，会死循环",-1),a("h4",{id:"hashmap的size为什么必须是2的整数次方",tabindex:"-1"},[l("hashmap的size为什么必须是2的整数次方 "),a("a",{class:"header-anchor",href:"#hashmap的size为什么必须是2的整数次方","aria-label":'Permalink to "hashmap的size为什么必须是2的整数次方"'},"​")],-1),a("p",null,"当 length 为 2 的 n 次⽅时，h & (length - 1)就相当于对 length 取模，⽽且速度⽐直接取模快得多，这是 HashMap 在速度上的⼀个优化。⽽且每次扩容时都是翻倍",-1)])),"main-header":e(()=>[r(n.$slots,"main-header")]),"main-header-after":e(()=>[r(n.$slots,"main-header-after")]),"main-nav":e(()=>[r(n.$slots,"main-nav")]),"main-content-before":e(()=>[r(n.$slots,"main-content-before")]),"main-content":e(()=>[r(n.$slots,"main-content")]),"main-content-after":e(()=>[r(n.$slots,"main-content-after")]),"main-nav-before":e(()=>[r(n.$slots,"main-nav-before")]),"main-nav-after":e(()=>[r(n.$slots,"main-nav-after")]),comment:e(()=>[r(n.$slots,"comment")]),footer:e(()=>[r(n.$slots,"footer")]),aside:e(()=>[r(n.$slots,"aside")]),"aside-custom":e(()=>[r(n.$slots,"aside-custom")]),default:e(()=>[r(n.$slots,"default")]),_:3},8,["frontmatter"])}}};export{B as default,P as usePageData};
