import{_ as P}from"./ValaxyMain.vue_vue_type_style_index_0_lang.DXFDIcRI.js";import{f as T,a as m,u as _}from"./chunks/vue-router.CE6eJGTm.js";import{O as k,a4 as a,V as t,U as l,X as e,u as b,P as f,A as C}from"./framework.CgPPQfmH.js";import"./app.2Hk-Pb-P.js";import"./chunks/dayjs.CCYrSalk.js";import"./chunks/vue-i18n.BoM8szIi.js";import"./chunks/pinia.BjFmakTL.js";import"./chunks/@vueuse/motion.Cp--YhDB.js";import"./chunks/nprogress.BahbDzmd.js";import"./YunComment.vue_vue_type_style_index_0_lang.DC8N30BB.js";import"./index.C5okkQwF.js";import"./YunPageHeader.vue_vue_type_script_setup_true_lang.PEAAi8W5.js";import"./post.CGlAV6UI.js";const g=T("/posts/study notes/java base knowledge/计算机网络",async r=>JSON.parse('{"title":"计算机网络","description":"","frontmatter":{"title":"计算机网络","date":"2025-04-19","updated":"2025-04-19","categories":"java","tags":["java","笔记"],"top":1},"headers":[{"level":3,"title":"1、三次握手、两次握手不行","slug":"_1、三次握手、两次握手不行","link":"#_1、三次握手、两次握手不行","children":[]},{"level":3,"title":"2、四次挥手","slug":"_2、四次挥手","link":"#_2、四次挥手","children":[]},{"level":3,"title":"3、POST和GET的区别","slug":"_3、post和get的区别","link":"#_3、post和get的区别","children":[]},{"level":3,"title":"4、TCP、UDP区别","slug":"_4、tcp、udp区别","link":"#_4、tcp、udp区别","children":[]},{"level":3,"title":"5、HTTP1.0 1.1 2.0的区别","slug":"_5、http1-0-1-1-2-0的区别","link":"#_5、http1-0-1-1-2-0的区别","children":[]},{"level":3,"title":"7、HTTP常用状态码","slug":"_7、http常用状态码","link":"#_7、http常用状态码","children":[]},{"level":3,"title":"8、ARP协议的工作原理","slug":"_8、arp协议的工作原理","link":"#_8、arp协议的工作原理","children":[]},{"level":3,"title":"9、为什么TIME-WAIT状态必须等待2MSL的时间","slug":"_9、为什么time-wait状态必须等待2msl的时间","link":"#_9、为什么time-wait状态必须等待2msl的时间","children":[]},{"level":3,"title":"10、TCP协议如何保证可靠传输","slug":"_10、tcp协议如何保证可靠传输","link":"#_10、tcp协议如何保证可靠传输","children":[]},{"level":3,"title":"11、粘包&产生原因&解决方法","slug":"_11、粘包-产生原因-解决方法","link":"#_11、粘包-产生原因-解决方法","children":[]},{"level":3,"title":"12、输入URL地址到显示主页的过程","slug":"_12、输入url地址到显示主页的过程","link":"#_12、输入url地址到显示主页的过程","children":[]},{"level":3,"title":"13、DNS的解析过程","slug":"_13、dns的解析过程","link":"#_13、dns的解析过程","children":[]},{"level":3,"title":"14、对HTTP长连接和短连接的理解。分别应用于哪些场景？","slug":"_14、对http长连接和短连接的理解。分别应用于哪些场景","link":"#_14、对http长连接和短连接的理解。分别应用于哪些场景","children":[]},{"level":3,"title":"15、拦截器的作用","slug":"_15、拦截器的作用","link":"#_15、拦截器的作用","children":[]},{"level":3,"title":"16、HTTP是文本协议还是二进制协议","slug":"_16、http是文本协议还是二进制协议","link":"#_16、http是文本协议还是二进制协议","children":[]},{"level":3,"title":"17、TCP四层模型、OSI七层模型","slug":"_17、tcp四层模型、osi七层模型","link":"#_17、tcp四层模型、osi七层模型","children":[]},{"level":3,"title":"18、restful风格","slug":"_18、restful风格","link":"#_18、restful风格","children":[]},{"level":3,"title":"19、HTTP协议和RPC协议的区别","slug":"_19、http协议和rpc协议的区别","link":"#_19、http协议和rpc协议的区别","children":[]},{"level":3,"title":"20、websocket和socket的区别","slug":"_20、websocket和socket的区别","link":"#_20、websocket和socket的区别","children":[]},{"level":3,"title":"21、NAT技术","slug":"_21、nat技术","link":"#_21、nat技术","children":[]},{"level":3,"title":"22、进程间通信方式","slug":"_22、进程间通信方式","link":"#_22、进程间通信方式","children":[]},{"level":3,"title":"23、cookie和session的区别","slug":"_23、cookie和session的区别","link":"#_23、cookie和session的区别","children":[]}],"relativePath":"pages/posts/study notes/java base knowledge/计算机网络.md","lastUpdated":1745542762000}'),{lazy:(r,s)=>r.name===s.name}),U={__name:"计算机网络",setup(r,{expose:s}){var u;const{data:p}=g(),d=_(),o=m(),i=Object.assign(o.meta.frontmatter||{},((u=p.value)==null?void 0:u.frontmatter)||{});return o.meta.frontmatter=i,d.currentRoute.value.data=p.value,C("valaxy:frontmatter",i),globalThis.$frontmatter=i,s({frontmatter:{title:"计算机网络",date:"2025-04-19",updated:"2025-04-19",categories:"java",tags:["java","笔记"],top:1}}),(n,h)=>{const c=P;return f(),k(c,{frontmatter:b(i)},{"main-content-md":a(()=>h[0]||(h[0]=[l("h1",{id:"计算机网络",tabindex:"-1"},[e("计算机网络 "),l("a",{class:"header-anchor",href:"#计算机网络","aria-label":'Permalink to "计算机网络"'},"​")],-1),l("h3",{id:"_1、三次握手、两次握手不行",tabindex:"-1"},[e("1、三次握手、两次握手不行 "),l("a",{class:"header-anchor",href:"#_1、三次握手、两次握手不行","aria-label":'Permalink to "1、三次握手、两次握手不行"'},"​")],-1),l("p",null,"第⼀次握⼿：客户端给服务器发送⼀个 SYN 报⽂。",-1),l("p",null,"客户端处于SYN_SEND状态",-1),l("p",null,"第⼆次握⼿：服务器收到 SYN 报⽂之后，会应答⼀个 SYN+ACK 报⽂。",-1),l("p",null,"服务器处于SYN_REVD状态",-1),l("p",null,"第三次握⼿：客户端收到 SYN+ACK 报⽂之后，会回应⼀个 ACK 报⽂。",-1),l("p",null,"服务器收到 ACK 报⽂之后，三次握⼿建⽴完成。",-1),l("p",null,"也是处于establised状态",-1),l("p",null,"作⽤是为了确认双⽅的接收与发送能⼒是否正常、指定自己的初始化序列号，为后面的可靠传送做准备",-1),l("p",null,"第三次握手是可以携带数据的",-1),l("p",null,[l("strong",null,"这⾥我顺便解释⼀下为啥只有三次握⼿才能确认双⽅的接受与发送能⼒是否正常，⽽两次却不可以"),e("：")],-1),l("p",null,"第⼀次握⼿：客户端发送⽹络包，服务端收到了。这样服务端就能得出结论：客户端的发送能⼒、服务端的接收能⼒是正常的。",-1),l("p",null,"第⼆次握⼿：服务端发包，客户端收到了。这样客户端就能得出结论：服务端的接收、发送能⼒，客户端的接收、发送能⼒是正常的。不过此时服务器并不能确认客户端的接收能⼒是否正常。",-1),l("p",null,"第三次握⼿：客户端发包，服务端收到了。这样服务端就能得出结论：客户端的接收、发送能⼒正常，服务器⾃⼰的发送、接收能⼒也正常。",-1),l("h3",{id:"_2、四次挥手",tabindex:"-1"},[e("2、四次挥手 "),l("a",{class:"header-anchor",href:"#_2、四次挥手","aria-label":'Permalink to "2、四次挥手"'},"​")],-1),l("p",null,[e("1、第⼀次挥手：客户端发送⼀个 FIN 报⽂，报⽂中会指定⼀个序列号。此时客户端处于"),l("strong",null,"CLOSED_WAIT1"),e("状态。")],-1),l("p",null,"2、第⼆次握⼿：服务端收到 FIN 之后，会发送 ACK 报⽂，且把客户端的序列号值 + 1 作为 ACK 报⽂的序列号",-1),l("p",null,[e("值，表明已经收到客户端的报⽂了，此时服务端处于 "),l("strong",null,"CLOSE_WAIT2"),e("状态。")],-1),l("p",null,"3、第三次挥⼿：如果服务端也想断开连接了，和客户端的第⼀次挥⼿⼀样，发给 FIN 报⽂，且指定⼀个序列号。",-1),l("p",null,[e("此时服务端处于 "),l("strong",null,"LAST_ACK"),e(" 的状态。")],-1),l("p",null,"4、第四次挥⼿：客户端收到 FIN 之后，⼀样发送⼀个 ACK 报⽂作为应答，且把服务端的序列号值 + 1 作为⾃⼰",-1),l("p",null,[e("ACK 报⽂的序列号值，此时客户端处于 "),l("strong",null,"TIME_WAIT"),e(" 状态。需要过⼀阵⼦以确保服务端收到⾃⼰的 ACK 报⽂之后才会进⼊ CLOSED 状态")],-1),l("p",null,"5、服务端收到 ACK 报⽂之后，就处于关闭连接了，处于 CLOSED 状态",-1),l("h3",{id:"_3、post和get的区别",tabindex:"-1"},[e("3、POST和GET的区别 "),l("a",{class:"header-anchor",href:"#_3、post和get的区别","aria-label":'Permalink to "3、POST和GET的区别"'},"​")],-1),l("p",null,"GET用于获取资源，而POST用于传输实体主体",-1),l("p",null,"GET 和 POST 的请求都能使⽤额外的参数，但是 GET 的参数是以查询字符串出现在 URL 中，⽽ POST 的参数存储在实体主体中。",-1),l("h6",{id:"安全性",tabindex:"-1"},[e("安全性 "),l("a",{class:"header-anchor",href:"#安全性","aria-label":'Permalink to "安全性"'},"​")],-1),l("p",null,"安全的HTTP方法不会改变服务器的状态，只读",-1),l("p",null,"安全的方法：GET、HEAD、OPTIONS",-1),l("p",null,"不安全的方法：PUT、DELETE、POST",-1),l("h6",{id:"幂等性",tabindex:"-1"},[e("幂等性 "),l("a",{class:"header-anchor",href:"#幂等性","aria-label":'Permalink to "幂等性"'},"​")],-1),l("p",null,"同样的请求被执行一次和连续执行多次的效果是一样的，服务器的状态也是一样的",-1),l("p",null,"幂等：GET、HEAD、PUT、DELETE",-1),l("p",null,"而POST不是",-1),l("h3",{id:"_4、tcp、udp区别",tabindex:"-1"},[e("4、TCP、UDP区别 "),l("a",{class:"header-anchor",href:"#_4、tcp、udp区别","aria-label":'Permalink to "4、TCP、UDP区别"'},"​")],-1),l("h6",{id:"tcp",tabindex:"-1"},[e("TCP "),l("a",{class:"header-anchor",href:"#tcp","aria-label":'Permalink to "TCP"'},"​")],-1),l("p",null,"是面向连接的协议，发送数据前要先建立连接。",-1),l("p",null,"tcp提供可靠的服务，数据不会丢失，没有重复且按顺序到达",-1),l("p",null,"TCP是点对点的通信。面向字节流，发送数据时以字节为单位，，一个数据包可以拆分为若干组进行发送",-1),l("p",null,"首部开销有20字节 。。。。",-1),l("p",null,"提供全双工通信，都有发送缓存和接收缓存",-1),l("h6",{id:"udp",tabindex:"-1"},[e("UDP "),l("a",{class:"header-anchor",href:"#udp","aria-label":'Permalink to "UDP"'},"​")],-1),l("p",null,"是无连接的协议，发送数据不要建立连接，收到也不需要给出确认",-1),l("p",null,"通信有多种方式，可以进行一对一、一对多、多对一、多对多的通信",-1),l("p",null,"udp是面向报文的，udp是适合传输少量数据",-1),l("p",null,"首部开销为8字节",-1),l("h3",{id:"_5、http1-0-1-1-2-0的区别",tabindex:"-1"},[e("5、HTTP1.0 1.1 2.0的区别 "),l("a",{class:"header-anchor",href:"#_5、http1-0-1-1-2-0的区别","aria-label":'Permalink to "5、HTTP1.0 1.1 2.0的区别"'},"​")],-1),l("p",null,"http1.0 不能长连接，只能短连接",-1),l("p",null,"http1.1 可以长连接",-1),l("p",null,"Http2.0 采用了多路复用 把HTTP报文分解成更小的二进制帧来传送，不同的HTTP报文可以混合在一个TCP连接上传输，服务器收到后，再根据二进制帧里面存放的ID分类",-1),l("h3",{id:"_7、http常用状态码",tabindex:"-1"},[e("7、HTTP常用状态码 "),l("a",{class:"header-anchor",href:"#_7、http常用状态码","aria-label":'Permalink to "7、HTTP常用状态码"'},"​")],-1),l("p",null,"1xx信息性状态码 101 切换请求协议 从http切换到websocket",-1),l("p",null,"2xx成功状态码 200请求成功",-1),l("p",null,"3xx重定向状态码。301请求资源永久移动，返回新url。302请求资源临时移动，继续",-1),l("p",null,"304 协商缓存命中",-1),l("p",null,"4xx客户端错误状态码 400客户端语法错误，服务端理解不了",-1),l("p",null,"401 当前请求要认证 403服务器理解请求，但拒绝执行，服务器禁止访问",-1),l("p",null,"5xx 服务端错误状态码 500服务器内部错误 503服务器繁忙",-1),l("h3",{id:"_8、arp协议的工作原理",tabindex:"-1"},[e("8、ARP协议的工作原理 "),l("a",{class:"header-anchor",href:"#_8、arp协议的工作原理","aria-label":'Permalink to "8、ARP协议的工作原理"'},"​")],-1),l("p",null,"网络层的ARP协议完成了IP地址与物理地址的映射",-1),l("p",null,"每台主机都会在自己的ARP缓冲区建立一个ARP列表，表示IP地址和MAC地址的对应关系",-1),l("h3",{id:"_9、为什么time-wait状态必须等待2msl的时间",tabindex:"-1"},[e("9、为什么TIME-WAIT状态必须等待2MSL的时间 "),l("a",{class:"header-anchor",href:"#_9、为什么time-wait状态必须等待2msl的时间","aria-label":'Permalink to "9、为什么TIME-WAIT状态必须等待2MSL的时间"'},"​")],-1),l("p",null,"为了保证客户端发送的最后一个ACK报文段能到达服务端，服务器会超时重传FIN+ACK报文段，A重传一次确认，重新启动计时器，A和B都正常进入CLOSED状态",-1),l("p",null,"防止已失效的连接请求报文段出现在本连接中",-1),l("h3",{id:"_10、tcp协议如何保证可靠传输",tabindex:"-1"},[e("10、TCP协议如何保证可靠传输 "),l("a",{class:"header-anchor",href:"#_10、tcp协议如何保证可靠传输","aria-label":'Permalink to "10、TCP协议如何保证可靠传输"'},"​")],-1),l("p",null,"1、数据包校验和：检测数据在传输过程中的任何变化",-1),l("p",null,"2、对失序数据包重排序：IP数据报的到达可能会失序，TCP需要对失序数据进行重新排序",-1),l("p",null,"3、应答机制确认连接",-1),l("p",null,"4、超时重传：当TCP发出一个段后，启动一个定时器，等待目的端确认收到这个报文段，如果不能收到确认，将重发这个报文段",-1),l("p",null,"5、流量控制：TCP接收端只允许另一端发送接收端缓存区所能接纳的数据",-1),l("p",null,"利用滑动窗口实现",-1),l("h3",{id:"_11、粘包-产生原因-解决方法",tabindex:"-1"},[e("11、粘包&产生原因&解决方法 "),l("a",{class:"header-anchor",href:"#_11、粘包-产生原因-解决方法","aria-label":'Permalink to "11、粘包&产生原因&解决方法"'},"​")],-1),l("p",null,"如果客户端连续不断向服务端发送数据包时，服务端接收端数据会出现两个数据包粘在一起的情况",-1),l("p",null,"TCP是基于字节流的，把这些数据块看成一连串无结构的字节流，没有边界",-1),l("p",null,"在TCP的首部没有表示数据长度的字段",-1),l("h6",{id:"发送方产生粘包",tabindex:"-1"},[e("发送方产生粘包 "),l("a",{class:"header-anchor",href:"#发送方产生粘包","aria-label":'Permalink to "发送方产生粘包"'},"​")],-1),l("p",null,"客户端与服务器经常保持长连接的状态，双方在连接不断开的情况下，可以一直传输数据。但是较小的数据包会进行合并发送，此时已经粘包了",-1),l("h6",{id:"接收方产生粘包",tabindex:"-1"},[e("接收方产生粘包 "),l("a",{class:"header-anchor",href:"#接收方产生粘包","aria-label":'Permalink to "接收方产生粘包"'},"​")],-1),l("p",null,"TCP将读取到的数据放在接收缓冲区，由应用层来主动获取。在程序中调用的读取数据函数不能及时把缓冲区中的数据拿出来，而下一个数据又到末尾，等读取数据时就是粘包",-1),l("p",null,"解决方法：",-1),l("p",null,"分包机制：",-1),l("p",null,"特殊字符控制、在包头首部添加数据包的长度",-1),l("h3",{id:"_12、输入url地址到显示主页的过程",tabindex:"-1"},[e("12、输入URL地址到显示主页的过程 "),l("a",{class:"header-anchor",href:"#_12、输入url地址到显示主页的过程","aria-label":'Permalink to "12、输入URL地址到显示主页的过程"'},"​")],-1),l("ol",null,[l("li",null,"DNS 解析：浏览器查询 DNS，获取域名对应的 IP 地址：具体过程包括浏览器搜索⾃身的 DNS 缓存、搜索操")],-1),l("p",null,"作系统的 DNS 缓存、读取本地的 Host ⽂件和向本地 DNS 服务器进⾏查询等。对于向本地 DNS 服务器进⾏",-1),l("p",null,"查询，如果要查询的域名包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析(此解析具有",-1),l("p",null,"权威性)；如果要查询的域名不由本地 DNS 服务器区域解析，但该服务器已缓存了此⽹址映射关系，则调⽤这",-1),l("p",null,"个 IP 地址映射，完成域名解析（此解析不具有权威性）。如果本地域名服务器并未缓存该⽹址映射关系，那",-1),l("p",null,"么将根据其设置发起递归查询或者迭代查询；",-1),l("ol",{start:"2"},[l("li",null,"TCP 连接：浏览器获得域名对应的 IP 地址以后，浏览器向服务器请求建⽴链接，发起三次握⼿；"),l("li",null,"发送 HTTP 请求：TCP 连接建⽴起来后，浏览器向服务器发送 HTTP 请求；"),l("li",null,"服务器处理请求并返回 HTTP 报⽂：服务器接收到这个请求，并根据路径参数映射到特定的请求处理器进⾏处")],-1),l("p",null,"理，并将处理结果及相应的视图返回给浏览器；",-1),l("ol",{start:"5"},[l("li",null,"浏览器解析渲染⻚⾯：浏览器解析并渲染视图，若遇到对 js ⽂件、css ⽂件及图⽚等静态资源的引⽤，则᯿复")],-1),l("p",null,"上述步骤并向服务器请求这些资源；浏览器根据其请求到的资源、数据渲染⻚⾯，最终向⽤户呈现⼀个完整的",-1),l("p",null,"⻚⾯。",-1),l("ol",{start:"6"},[l("li",null,"连接结束")],-1),l("h3",{id:"_13、dns的解析过程",tabindex:"-1"},[e("13、DNS的解析过程 "),l("a",{class:"header-anchor",href:"#_13、dns的解析过程","aria-label":'Permalink to "13、DNS的解析过程"'},"​")],-1),l("ol",null,[l("li",null,"主机向本地域名服务器的查询⼀般都是采⽤递归查询。所谓递归查询就是：如果主机所询问的本地域名服务器")],-1),l("p",null,"不知道被查询的域名的 IP 地址，那么本地域名服务器就以 DNS 客户的身份，向根域名服务器继续发出查询请",-1),l("p",null,"求报⽂(即替主机继续查询)，⽽不是让主机⾃⼰进⾏下⼀步查询。因此，递归查询返回的查询结果或者是所要",-1),l("p",null,"查询的 IP 地址，或者是报错，表示⽆法查询到所需的 IP 地址。",-1),l("ol",{start:"2"},[l("li",null,"本地域名服务器向根域名服务器的查询的迭代查询。迭代查询的特点：当根域名服务器收到本地域名服务器发")],-1),l("p",null,"出的迭代查询请求报⽂时，要么给出所要查询的 IP 地址，要么告诉本地服务器：“你下⼀步应当向哪⼀个域名",-1),l("p",null,"服务器进⾏查询”。然后让本地服务器进⾏后续的查询。根域名服务器通常是把⾃⼰知道的顶级域名服务器的",-1),l("p",null,"IP 地址告诉本地域名服务器，让本地域名服务器再向顶级域名服务器查询。顶级域名服务器在收到本地域名",-1),l("p",null,"服务器的查询请求后，要么给出所要查询的 IP 地址，要么告诉本地服务器下⼀步应当向哪⼀个权限域名服务",-1),l("p",null,"器进⾏查询。最后，本地域名服务器得到了所要解析的 IP 地址或报错，然后把这个结果返回给发起查询的主",-1),l("p",null,"机",-1),l("h3",{id:"_14、对http长连接和短连接的理解。分别应用于哪些场景",tabindex:"-1"},[e("14、对HTTP长连接和短连接的理解。分别应用于哪些场景？ "),l("a",{class:"header-anchor",href:"#_14、对http长连接和短连接的理解。分别应用于哪些场景","aria-label":'Permalink to "14、对HTTP长连接和短连接的理解。分别应用于哪些场景？"'},"​")],-1),l("p",null,"1.0默认使用短连接，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束，就中断连接。",-1),l("p",null,"1.1默认使用长连接。响应头会加上Connection:keep-alive的代码",-1),l("p",null,"长连接是客户端和服务器之间建立的一种持久连接，通常用于长时间保持通信状态，可以减少连接的建立和关闭的开销。",-1),l("p",null,"通常是在应用层连接的，通过TCP协议的keep-alive机制，使得客户端和服务器之间一直保持打开状态，直到某一方主动断开或者出现异常",-1),l("p",null,"客户端可以在同一个连接上发送多个请求，服务器也可以返回多个响应",-1),l("p",null,"提高长连接的效率，采用措施：",-1),l("ol",null,[l("li",null,[l("p",null,"心跳机制：为了保持长连接的有效性，可以采用心跳机制，定期向服务器发送一些无实际意义的数据包，以检测连接是否正常。")]),l("li",null,[l("p",null,"线程池：长连接通常会占用大量的线程资源，为了避免线程资源的浪费，可以采用线程池来管理线程资源，提高长连接的效率和稳定性。")]),l("li",null,[l("p",null,"断线重连：如果长连接由于网络异常或其他原因断开，可以采取断线重连的方式，重新建立连接，保证长连接的稳定性和可靠性。")]),l("li",null,[l("p",null,"超时机制：为了防止长连接持续时间过长，可以设置超时机制，当长连接超过一定时间没有活动时，自动关闭连接，释放资源。")])],-1),l("h3",{id:"_15、拦截器的作用",tabindex:"-1"},[e("15、拦截器的作用 "),l("a",{class:"header-anchor",href:"#_15、拦截器的作用","aria-label":'Permalink to "15、拦截器的作用"'},"​")],-1),l("ol",null,[l("li",null,[l("p",null,"权限控制：拦截器可以用于实现权限控制，例如检查用户是否具有访问某个资源的权限，如果没有权限则可以拦截请求并返回错误信息。")]),l("li",null,[l("p",null,"日志记录：拦截器可以用于记录系统的操作日志，例如记录用户的登录、操作等信息，以便后续的审计和查错。")]),l("li",null,[l("p",null,"性能监控：拦截器可以用于监控系统的性能，例如记录请求的响应时间、请求的处理时间等信息，以便后续的性能优化。")]),l("li",null,[l("p",null,"数据加解密：拦截器可以用于对数据进行加解密操作，例如对请求参数、响应结果等进行加密，以保护数据的安全性。")]),l("li",null,[l("p",null,"缓存管理：拦截器可以用于实现缓存管理，例如对请求结果进行缓存，以提高系统的性能和响应速度。")])],-1),l("h3",{id:"_16、http是文本协议还是二进制协议",tabindex:"-1"},[e("16、HTTP是文本协议还是二进制协议 "),l("a",{class:"header-anchor",href:"#_16、http是文本协议还是二进制协议","aria-label":'Permalink to "16、HTTP是文本协议还是二进制协议"'},"​")],-1),l("p",null,"是一种文本协议，使用ASCII码表示文本内容，并使用HTTP报文的格式进行通信。",-1),l("p",null,"HTTP协议的报文分为请求报文和响应报文两种类型，每个报文都包含一个起始行、多个首部字段和一个实体主体部分。",-1),l("p",null,"起始行包含了请求或响应的方法、URL、HTTP版本等信息，首部字段包含了一些元数据，如请求或响应的头部信息、Cookie信息等，实体主体部分包含了请求或响应的具体内容。",-1),l("p",null,"虽然HTTP协议是文本协议，但是它可以传输二进制数据，例如图片、音频、视频等。在传输二进制数据时，通常使用Base64编码将二进制数据转换为文本形式，然后在HTTP报文中进行传输。",-1),l("h3",{id:"_17、tcp四层模型、osi七层模型",tabindex:"-1"},[e("17、TCP四层模型、OSI七层模型 "),l("a",{class:"header-anchor",href:"#_17、tcp四层模型、osi七层模型","aria-label":'Permalink to "17、TCP四层模型、OSI七层模型"'},"​")],-1),l("p",null,"TCP/IP协议四层模型",-1),l("p",null,"1、链路层：负责将数据帧从一个物理接口传输到另一个物理接口",-1),l("p",null,"2、网络层：负责将数据包从源主机传递到目标主机",-1),l("p",null,"3、传输层：提供了端到端的可靠性和错误处理机制",-1),l("p",null,"4、应用层：为应用程序提供网络服务",-1),l("h3",{id:"_18、restful风格",tabindex:"-1"},[e("18、restful风格 "),l("a",{class:"header-anchor",href:"#_18、restful风格","aria-label":'Permalink to "18、restful风格"'},"​")],-1),l("p",null,"一种web服务架构风格，通过http协议实现应用程序间的通信",-1),l("p",null,"rest是一种基于资源的架构风格，它将所有的web资源，如文本、图片、视频等，都视为资源，每个资源都有唯一的标识符（URI）",-1),l("p",null,"客户端使用http协议的get、post、put、delete方法等，访问这些uri 进行增删改查",-1),l("p",null,"设计原则：",-1),l("p",null,"1、基于http协议",-1),l("p",null,"2、uri是资源的标识符",-1),l("p",null,"3、传输的数据格式：通常是json和xml格式",-1),l("p",null,"4、状态码表示操作结果",-1),l("p",null,"5、用户界面和api分离",-1),l("h3",{id:"_19、http协议和rpc协议的区别",tabindex:"-1"},[e("19、HTTP协议和RPC协议的区别 "),l("a",{class:"header-anchor",href:"#_19、http协议和rpc协议的区别","aria-label":'Permalink to "19、HTTP协议和RPC协议的区别"'},"​")],-1),l("p",null,"功能层面：http协议是超文本传输协议，是万维网数据传输通信的基础，主要服务在网页端和服务端端数据传输上。RPC是远程过程调用协议，是实现不同计算机应用之间的数据通信。",-1),l("p",null,"实现层面：HTTP是成熟的应用层协议，定义了通信报文的一些格式。RPC是一种协议规范，并没有具体的实现。在实现RPC协议框架的时候，可以自定义报文通信的一个协议规范和自定义序列化方式或者自定义网络通信协议的类型",-1),l("p",null,"应用层面：都能实现跨网络节点之间的服务通信，底层都使用了一个TCP协议作为通信基础。",-1),l("h3",{id:"_20、websocket和socket的区别",tabindex:"-1"},[e("20、websocket和socket的区别 "),l("a",{class:"header-anchor",href:"#_20、websocket和socket的区别","aria-label":'Permalink to "20、websocket和socket的区别"'},"​")],-1),l("p",null,"socket套接字，需要三个参数：ip+端口+协议，可以完成对TCP/IP协议的高度封装，屏蔽网络细节，方便网络编程。建立的连接为长连接，客户端与服务器相互连接",-1),l("p",null,"websocket是应用层的通信协议，是在单个TCP连接上进行全双工通信的协议，为了解决HTTP协议无法实现实时双向通信的问题而设计的。传统的HTTP协议只能实现请求响应的方式，websocket支持双向通信，客户端和服务器可以随时向对方发送消息",-1),l("p",null,"发送接收 像tcp请求",-1),l("h3",{id:"_21、nat技术",tabindex:"-1"},[e("21、NAT技术 "),l("a",{class:"header-anchor",href:"#_21、nat技术","aria-label":'Permalink to "21、NAT技术"'},"​")],-1),l("p",null,"网络地址转换技术，可以将一个私有网络中的ip地址转换成公共网络中的ip地址，私有网络的主机可以与公共网络中的主机通信。",-1),l("p",null,"这个过程是在路由器上进行的。",-1),l("p",null,"当一个主机向互联网发送数据包时，路由器会将该数据包中的源ip地址替换为路由器的公共ip地址，并将该数据包转发到公共网络中；当公共网络中的主机向私有网络中的主机发送数据包时，路由器会将该数据包中的目标ip地址替换为私有网络中的主机的ip地址",-1),l("h3",{id:"_22、进程间通信方式",tabindex:"-1"},[e("22、进程间通信方式 "),l("a",{class:"header-anchor",href:"#_22、进程间通信方式","aria-label":'Permalink to "22、进程间通信方式"'},"​")],-1),l("p",null,"进程间通信（IPC）是指在不同进程之间传播或交换信息。",-1),l("p",null,"常见的通信方式：",-1),l("h4",{id:"管道",tabindex:"-1"},[e("管道 "),l("a",{class:"header-anchor",href:"#管道","aria-label":'Permalink to "管道"'},"​")],-1),l("p",null,"最简单的进程间通信方式，通过管道的读写端进行数据的传输",-1),l("h4",{id:"消息队列",tabindex:"-1"},[e("消息队列 "),l("a",{class:"header-anchor",href:"#消息队列","aria-label":'Permalink to "消息队列"'},"​")],-1),l("p",null,"是一种通过消息传递进行进程间通信的方式",-1),l("h4",{id:"信号量",tabindex:"-1"},[e("信号量 "),l("a",{class:"header-anchor",href:"#信号量","aria-label":'Permalink to "信号量"'},"​")],-1),l("p",null,"用于进程间同步和互斥的机制。进程可以通过信号量进行资源访问，控制进程间的执行顺序和并发访问",-1),l("h3",{id:"_23、cookie和session的区别",tabindex:"-1"},[e("23、cookie和session的区别 "),l("a",{class:"header-anchor",href:"#_23、cookie和session的区别","aria-label":'Permalink to "23、cookie和session的区别"'},"​")],-1),l("p",null,"cookie是保存在客户端文件中的，存在安全风险，可以设置过期时间",-1),l("p",null,"session是在服务器内存或数据库中的，更加安全，生命周期是由服务器控制的",-1)])),"main-header":a(()=>[t(n.$slots,"main-header")]),"main-header-after":a(()=>[t(n.$slots,"main-header-after")]),"main-nav":a(()=>[t(n.$slots,"main-nav")]),"main-content-before":a(()=>[t(n.$slots,"main-content-before")]),"main-content":a(()=>[t(n.$slots,"main-content")]),"main-content-after":a(()=>[t(n.$slots,"main-content-after")]),"main-nav-before":a(()=>[t(n.$slots,"main-nav-before")]),"main-nav-after":a(()=>[t(n.$slots,"main-nav-after")]),comment:a(()=>[t(n.$slots,"comment")]),footer:a(()=>[t(n.$slots,"footer")]),aside:a(()=>[t(n.$slots,"aside")]),"aside-custom":a(()=>[t(n.$slots,"aside-custom")]),default:a(()=>[t(n.$slots,"default")]),_:3},8,["frontmatter"])}}};export{U as default,g as usePageData};
