import{_ as c}from"./ValaxyMain.vue_vue_type_style_index_0_lang.DXFDIcRI.js";import{f as b,a as f,u as y}from"./chunks/vue-router.CE6eJGTm.js";import{O as g,a4 as a,V as r,U as l,X as e,u as k,P as _,A as q}from"./framework.CgPPQfmH.js";import"./app.2Hk-Pb-P.js";import"./chunks/dayjs.CCYrSalk.js";import"./chunks/vue-i18n.BoM8szIi.js";import"./chunks/pinia.BjFmakTL.js";import"./chunks/@vueuse/motion.Cp--YhDB.js";import"./chunks/nprogress.BahbDzmd.js";import"./YunComment.vue_vue_type_style_index_0_lang.DC8N30BB.js";import"./index.C5okkQwF.js";import"./YunPageHeader.vue_vue_type_script_setup_true_lang.PEAAi8W5.js";import"./post.CGlAV6UI.js";const x=b("/posts/study notes/java base knowledge/mysql",async s=>JSON.parse('{"title":"mysql","description":"","frontmatter":{"title":"mysql","date":"2025-04-19","updated":"2025-04-19","categories":"java","tags":["java","笔记"],"top":1},"headers":[{"level":3,"title":"1、数据库优化","slug":"_1、数据库优化","link":"#_1、数据库优化","children":[]},{"level":3,"title":"2、聚集索引和非聚集索引","slug":"_2、聚集索引和非聚集索引","link":"#_2、聚集索引和非聚集索引","children":[]},{"level":3,"title":"3、mysql常见锁类型","slug":"_3、mysql常见锁类型","link":"#_3、mysql常见锁类型","children":[]},{"level":3,"title":"4、索引","slug":"_4、索引","link":"#_4、索引","children":[]},{"level":3,"title":"5、数据库查询的性能瓶颈及优化","slug":"_5、数据库查询的性能瓶颈及优化","link":"#_5、数据库查询的性能瓶颈及优化","children":[]},{"level":3,"title":"6、innodb","slug":"_6、innodb","link":"#_6、innodb","children":[]},{"level":3,"title":"7、关系性数据库和非关系性数据库的区别","slug":"_7、关系性数据库和非关系性数据库的区别","link":"#_7、关系性数据库和非关系性数据库的区别","children":[]},{"level":3,"title":"8、数据库事务","slug":"_8、数据库事务","link":"#_8、数据库事务","children":[]},{"level":3,"title":"9、数据量大的解决方案","slug":"_9、数据量大的解决方案","link":"#_9、数据量大的解决方案","children":[]},{"level":3,"title":"10、日志","slug":"_10、日志","link":"#_10、日志","children":[]},{"level":3,"title":"11、定位慢查询&分析","slug":"_11、定位慢查询-分析","link":"#_11、定位慢查询-分析","children":[]},{"level":3,"title":"12、数据库三范式","slug":"_12、数据库三范式","link":"#_12、数据库三范式","children":[]},{"level":3,"title":"13、数据库主从复制涉及到的线程","slug":"_13、数据库主从复制涉及到的线程","link":"#_13、数据库主从复制涉及到的线程","children":[]},{"level":3,"title":"14、mysql8.0版本更新了哪些？","slug":"_14、mysql8-0版本更新了哪些","link":"#_14、mysql8-0版本更新了哪些","children":[]},{"level":3,"title":"15、mysql中死锁如何解决","slug":"_15、mysql中死锁如何解决","link":"#_15、mysql中死锁如何解决","children":[]},{"level":3,"title":"16、MyISAM","slug":"_16、myisam","link":"#_16、myisam","children":[]},{"level":3,"title":"17、评估mysql一张表可以存储多少数据","slug":"_17、评估mysql一张表可以存储多少数据","link":"#_17、评估mysql一张表可以存储多少数据","children":[]},{"level":3,"title":"1、常用sql语句 语法","slug":"_1、常用sql语句-语法","link":"#_1、常用sql语句-语法","children":[]}],"relativePath":"pages/posts/study notes/java base knowledge/mysql.md","lastUpdated":1745542762000}'),{lazy:(s,i)=>s.name===i.name}),N={__name:"mysql",setup(s,{expose:i}){var u;const{data:d}=x(),p=y(),o=f(),t=Object.assign(o.meta.frontmatter||{},((u=d.value)==null?void 0:u.frontmatter)||{});return o.meta.frontmatter=t,p.currentRoute.value.data=d.value,q("valaxy:frontmatter",t),globalThis.$frontmatter=t,i({frontmatter:{title:"mysql",date:"2025-04-19",updated:"2025-04-19",categories:"java",tags:["java","笔记"],top:1}}),(n,h)=>{const m=c;return _(),g(m,{frontmatter:k(t)},{"main-content-md":a(()=>h[0]||(h[0]=[l("h1",{id:"mysql",tabindex:"-1"},[e("MySql "),l("a",{class:"header-anchor",href:"#mysql","aria-label":'Permalink to "MySql"'},"​")],-1),l("h3",{id:"_1、数据库优化",tabindex:"-1"},[e("1、数据库优化 "),l("a",{class:"header-anchor",href:"#_1、数据库优化","aria-label":'Permalink to "1、数据库优化"'},"​")],-1),l("p",null,"1、使用合适的索引：创建适当的索引，可以加快查询速度和提高数据库性能",-1),l("p",null,"2、优化sql查询语句",-1),l("p",null,"3、调整数据库参数：内存缓冲区大小、并发连接数等",-1),l("p",null,"4、数据库分区：将大表拆分为多个分区，可以提高查询效率和管理数据的灵活性",-1),l("h3",{id:"_2、聚集索引和非聚集索引",tabindex:"-1"},[e("2、聚集索引和非聚集索引 "),l("a",{class:"header-anchor",href:"#_2、聚集索引和非聚集索引","aria-label":'Permalink to "2、聚集索引和非聚集索引"'},"​")],-1),l("h4",{id:"聚集索引",tabindex:"-1"},[e("聚集索引 "),l("a",{class:"header-anchor",href:"#聚集索引","aria-label":'Permalink to "聚集索引"'},"​")],-1),l("p",null,"聚集索引决定了数据在磁盘上的物理存储顺序，是根据索引的键值对表中的数据进行排序和存储的方式",-1),l("p",null,"一个表只有一个聚集索引，通常是主键索引。如果没有主键，将使用第一个唯一索引作为聚集索引。",-1),l("p",null,"可以加快按索引键值进行查找的速度，减少磁盘I/O的次数",-1),l("h4",{id:"非聚集索引",tabindex:"-1"},[e("非聚集索引 "),l("a",{class:"header-anchor",href:"#非聚集索引","aria-label":'Permalink to "非聚集索引"'},"​")],-1),l("p",null,"独立于实际数据存储的情况下创建的索引结构，包含索引的键值和指向实际数据行的指针。",-1),l("p",null,"一个表可以有多个非聚集索引，可以基于不同的列创建",-1),l("p",null,"提供了更快的查找速度（不需要按照特定的顺序存储数据）",-1),l("h3",{id:"_3、mysql常见锁类型",tabindex:"-1"},[e("3、mysql常见锁类型 "),l("a",{class:"header-anchor",href:"#_3、mysql常见锁类型","aria-label":'Permalink to "3、mysql常见锁类型"'},"​")],-1),l("h4",{id:"共享锁-读锁",tabindex:"-1"},[e("共享锁（读锁） "),l("a",{class:"header-anchor",href:"#共享锁-读锁","aria-label":'Permalink to "共享锁（读锁）"'},"​")],-1),l("p",null,"多个事务可以同时持有共享锁，用于允许并发读取操作",-1),l("p",null,"但会阻塞独占锁的获取",-1),l("h4",{id:"独占锁-写锁",tabindex:"-1"},[e("独占锁（写锁） "),l("a",{class:"header-anchor",href:"#独占锁-写锁","aria-label":'Permalink to "独占锁（写锁）"'},"​")],-1),l("p",null,"只有一个事务可以持有独占锁，用于防止其他事务读取或修改数据",-1),l("p",null,"会阻塞其他独占锁和共享锁的获取",-1),l("h4",{id:"意向共享锁-表级锁",tabindex:"-1"},[e("意向共享锁（表级锁） "),l("a",{class:"header-anchor",href:"#意向共享锁-表级锁","aria-label":'Permalink to "意向共享锁（表级锁）"'},"​")],-1),l("p",null,"表示一个事务想在表上获取共享锁",-1),l("h4",{id:"意向独占锁-表级锁",tabindex:"-1"},[e("意向独占锁（表级锁） "),l("a",{class:"header-anchor",href:"#意向独占锁-表级锁","aria-label":'Permalink to "意向独占锁（表级锁）"'},"​")],-1),l("p",null,"表示一个事务想在表上获取独占锁",-1),l("h4",{id:"记录锁-行锁",tabindex:"-1"},[e("记录锁（行锁） "),l("a",{class:"header-anchor",href:"#记录锁-行锁","aria-label":'Permalink to "记录锁（行锁）"'},"​")],-1),l("p",null,"锁定表中的特定记录，实现对记录级别的并发控制",-1),l("p",null,"可以是共享锁或独占锁",-1),l("h4",{id:"间隙锁",tabindex:"-1"},[e("间隙锁 "),l("a",{class:"header-anchor",href:"#间隙锁","aria-label":'Permalink to "间隙锁"'},"​")],-1),l("p",null,"可以防止幻读的发生",-1),l("h4",{id:"next-key锁",tabindex:"-1"},[e("next-key锁 "),l("a",{class:"header-anchor",href:"#next-key锁","aria-label":'Permalink to "next-key锁"'},"​")],-1),l("p",null,"记录锁和间隙锁的组合，用于实现可重复读事务级别",-1),l("p",null,"可以防止幻读和不可重复读的发生",-1),l("p",null,"在使用范围查询或索引键值重复的情况下自动加锁，用于解决索引键值冲突的问题",-1),l("p",null,"在索引上加锁，锁住范围内数据行和下一个索引值的间隙",-1),l("p",null,"语法：FOR UPDATE",-1),l("h3",{id:"_4、索引",tabindex:"-1"},[e("4、索引 "),l("a",{class:"header-anchor",href:"#_4、索引","aria-label":'Permalink to "4、索引"'},"​")],-1),l("h4",{id:"作用",tabindex:"-1"},[e("作用 "),l("a",{class:"header-anchor",href:"#作用","aria-label":'Permalink to "作用"'},"​")],-1),l("p",null,"加速数据检索：减少数据库的扫描量，通过快速定位数据，加快查询操作的速度",-1),l("p",null,"提高数据的唯一性和完整性：通过在索引列上创建唯一索引或主键索引，可以保证数据的唯一性和完整性",-1),l("p",null,"排序数据：可以帮助数据库按照特定的顺序进行排序，从而提高排序操作的效率",-1),l("h4",{id:"类型",tabindex:"-1"},[e("类型 "),l("a",{class:"header-anchor",href:"#类型","aria-label":'Permalink to "类型"'},"​")],-1),l("p",null,"B树索引：最常用的索引类型，可以快速定位需要查找的数据，支持范围查找、排序等操作",-1),l("p",null,"主键索引（特殊的B树索引）：用于唯一标识表中的每一行数据，主键索引是最常用的索引类型",-1),l("p",null,"哈希索引：将索引值进行哈希计算，将计算结果存储在哈希表中。快速定位到数据所在的位置，常用于map、set等数据结构",-1),l("p",null,"唯一索引：保证索引列的唯一性，一个表可以有多个唯一索引",-1),l("p",null,"全文索引：用于全文搜索，可以对文本数据进行高效的关键字搜索、模糊搜索",-1),l("h4",{id:"创建",tabindex:"-1"},[e("创建 "),l("a",{class:"header-anchor",href:"#创建","aria-label":'Permalink to "创建"'},"​")],-1),l("p",null,"可以通过CREATE INDEX语句在表的列上创建索引，也可以在创建表时指定索引",-1),l("h4",{id:"使用",tabindex:"-1"},[e("使用 "),l("a",{class:"header-anchor",href:"#使用","aria-label":'Permalink to "使用"'},"​")],-1),l("p",null,"可以通过EXPLAIN关键字来查看查询计划，判断是否使用了索引",-1),l("h4",{id:"优缺点",tabindex:"-1"},[e("优缺点 "),l("a",{class:"header-anchor",href:"#优缺点","aria-label":'Permalink to "优缺点"'},"​")],-1),l("p",null,"优点：提高查询性能，加速数据检索；保证数据的唯一性和完整性；排序数据的效率高",-1),l("p",null,"缺点：占用磁盘空间；增加数据插入、更新和删除的成本；索引会随着数据的增删改而变得不连续，需要定期维护",-1),l("h4",{id:"优化",tabindex:"-1"},[e("优化 "),l("a",{class:"header-anchor",href:"#优化","aria-label":'Permalink to "优化"'},"​")],-1),l("p",null,"1、选择合适的列添加索引，同时避免导致索引失效的操作，比如like、函数等",-1),l("p",null,"2、避免返回不必要的列，增加查询的效率",-1),l("p",null,"3、根据explain分析器适当优化sql结构，比如是否需要走全表扫描，避免子查询",-1),l("p",null,"4、分库分表：单表数据量大的情况下分库分表",-1),l("p",null,"5、读写分离：保证写操作的数据库承受更小的压力，缓解锁的竞争",-1),l("h4",{id:"最左前缀原则",tabindex:"-1"},[e("最左前缀原则 "),l("a",{class:"header-anchor",href:"#最左前缀原则","aria-label":'Permalink to "最左前缀原则"'},"​")],-1),l("p",null,"在使用索引进行查询时，只有在索引最左侧开始的连续一段字段才会被索引使用，不然不能用",-1),l("h4",{id:"回表查询",tabindex:"-1"},[e("回表查询 "),l("a",{class:"header-anchor",href:"#回表查询","aria-label":'Permalink to "回表查询"'},"​")],-1),l("p",null,"通过二级索引（非聚簇索引）找到对应的主键值，再通过主键值找到聚集索引中对应的整行数据",-1),l("h4",{id:"覆盖索引",tabindex:"-1"},[e("覆盖索引 "),l("a",{class:"header-anchor",href:"#覆盖索引","aria-label":'Permalink to "覆盖索引"'},"​")],-1),l("p",null,"是指查询使用了索引，并需要返回的列，在该索引种已经全部能够找到 使用id查询，直接走聚集索引查询，一次索引扫描，直接返回数据，性能高 如果返回的列中没有创建索引，有可能触发回表查询，尽量避免使用select *",-1),l("h4",{id:"超大分页如何处理",tabindex:"-1"},[e("超大分页如何处理 "),l("a",{class:"header-anchor",href:"#超大分页如何处理","aria-label":'Permalink to "超大分页如何处理"'},"​")],-1),l("p",null,"数据量比较大的时候，如果进行limit分页查询，在查询时，越往后，分页查询效率越低 如果limit 90000，10；其他记录丢弃，查询排序代价很大",-1),l("p",null,"通过创建覆盖索引能较好的提高性能，可以通过覆盖索引加子查询形式优化 前提 主键是自增的 select * from tb_sku t (select id from tb_sku order by limit 9000000,10) a where t.id = a.id;",-1),l("h4",{id:"索引创建原则",tabindex:"-1"},[e("索引创建原则 "),l("a",{class:"header-anchor",href:"#索引创建原则","aria-label":'Permalink to "索引创建原则"'},"​")],-1),l("p",null,"1、表中数据量过大，才会创建索引，并且添加索引的字段是查询比较频繁的字段，而且该表比较频繁 单表超过10w数据就可以 2、针对常用查询条件 where、order by、group by操作的字段建立索引 3、尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高 4、字符串类型的字段，长度较长，可以针对字段特点，建立前缀索引 5、尽量使用联合索引，减少单列索引 6、控制索引的数量 7、索引列不能存储null值，建表的时候使用not null进行约束",-1),l("h4",{id:"什么情况下不走索引",tabindex:"-1"},[e("什么情况下不走索引 "),l("a",{class:"header-anchor",href:"#什么情况下不走索引","aria-label":'Permalink to "什么情况下不走索引"'},"​")],-1),l("p",null,"数据量太小的话，索引反而会变慢",-1),l("p",null,"查询条件复杂的情况下，选择全局扫描",-1),l("p",null,"数据分布不均匀的话，需要读取大量数据块",-1),l("p",null,"没有合适的索引",-1),l("p",null,"所以，索引过多会影响性能，需要选择合适的数据类型和长度，经常进行读操作但写操作少的列适合建立索引",-1),l("h4",{id:"sql执行计划-explain",tabindex:"-1"},[e("sql执行计划 explain "),l("a",{class:"header-anchor",href:"#sql执行计划-explain","aria-label":'Permalink to "sql执行计划 explain"'},"​")],-1),l("p",null,"对sql语句进行语法分析，对sql语句进行查询重写，生成多个可能的执行计划",-1),l("p",null,"possible_key 当前sql可能会使用到的索引",-1),l("p",null,"key 当前sql实际命中的索引",-1),l("p",null,"Key_len 索引占用的大小",-1),l("p",null,"Extra 额外的优化建议",-1),l("p",null,"Type sql连接的类型 性能由好到差为null、system、const、ref、range、index、all",-1),l("p",null,"system 查询系统中的表",-1),l("p",null,"const根据主键查询",-1),l("p",null,"eq_ref 主键索引查询或唯一索引查询",-1),l("p",null,"ref 索引查询",-1),l("p",null,"range 范围查询",-1),l("p",null,"index 索引树扫描",-1),l("p",null,"all 全盘扫描",-1),l("h3",{id:"_5、数据库查询的性能瓶颈及优化",tabindex:"-1"},[e("5、数据库查询的性能瓶颈及优化 "),l("a",{class:"header-anchor",href:"#_5、数据库查询的性能瓶颈及优化","aria-label":'Permalink to "5、数据库查询的性能瓶颈及优化"'},"​")],-1),l("p",null,"查询语句的性能瓶颈：",-1),l("p",null,"1、复杂查询：当查询语句中包含多个表的连接、子查询、聚合函数等复杂操作时，查询性能可能会受到影响",-1),l("p",null,"2、没有正确使用索引：如果查询语句中的条件列没有创建索引或者不恰当，性能会下降",-1),l("p",null,"3、数据库结构设计不合理：表的关系设计不合理，或者字段类型选择不当，也会影响查询性能",-1),l("p",null,"优化方法：",-1),l("p",null,"1、优化查询语句：避免不必要的子查询、聚合操作",-1),l("p",null,"2、创建合适的索引：可以用EXPLAIN关键字来查看查询计划，判断是否用了索引",-1),l("p",null,"3、优化数据库结构：合理设计数据库表的关系和字段类型",-1),l("p",null,"4、数据库缓存：redis来缓存查询结果，减少数据库的访问次数，提高查询性能",-1),l("p",null,"5、连接池配置：控制连接数和最大等待时间",-1),l("h3",{id:"_6、innodb",tabindex:"-1"},[e("6、innodb "),l("a",{class:"header-anchor",href:"#_6、innodb","aria-label":'Permalink to "6、innodb"'},"​")],-1),l("h4",{id:"底层原理",tabindex:"-1"},[e("底层原理 "),l("a",{class:"header-anchor",href:"#底层原理","aria-label":'Permalink to "底层原理"'},"​")],-1),l("p",null,"是一种acid事务型存储引擎，底层是B+树实现的",-1),l("p",null,"B+树是一种多路平衡树，每个节点存储多个值，非叶子结点存储索引，叶子结点存储数据，叶子结点用双向链表进行关联，使得全局扫描能力更强",-1),l("h4",{id:"b-树和b树区别",tabindex:"-1"},[e("B+树和B树区别 "),l("a",{class:"header-anchor",href:"#b-树和b树区别","aria-label":'Permalink to "B+树和B树区别"'},"​")],-1),l("p",null,"B树的非叶子结点和叶子结点都会存放数据，B+树所有数据都会出现在叶子结点，查询的时候，B+树查找效率更加稳定。",-1),l("p",null,"范围查询的时候，B+树效率更高",-1),l("h4",{id:"事务型存储引擎",tabindex:"-1"},[e("事务型存储引擎 "),l("a",{class:"header-anchor",href:"#事务型存储引擎","aria-label":'Permalink to "事务型存储引擎"'},"​")],-1),l("p",null,"支持事务处理的数据库存储引擎，可以保证数据库中数据的完整性和一致性。",-1),l("p",null,"数据库操作要么全部成功，要么全部回滚。",-1),l("p",null,"支持ACID（原子性、一致性、隔离性、持久性）",-1),l("h4",{id:"如何解决幻读问题",tabindex:"-1"},[e("如何解决幻读问题 "),l("a",{class:"header-anchor",href:"#如何解决幻读问题","aria-label":'Permalink to "如何解决幻读问题"'},"​")],-1),l("p",null,"InnoDB通过MVCC（多版本并发控制）机制解决幻读问题",-1),l("p",null,"MVCC机制会为每个事务分配一个唯一的事务ID（Transaction ID），并为每条记录也分配一个唯一的版本号",-1),l("p",null,"InnoDB提供了两种方法：",-1),l("p",null,"1、使用间隙锁（Gap Lock）：在查询时，InnoDB会对查询结果的间隙加锁，以确保在该事务执行期间，其他事务无法在该间隙中插入新的数据。",-1),l("p",null,"2、使用Next-Key锁（Next-Key Lock）：在查询时，InnoDB会对查询结果及其相邻的间隙加锁，以确保在该事务执行期间，其他事务无法在该查询结果及其相邻的间隙中插入新的数据。",-1),l("h3",{id:"_7、关系性数据库和非关系性数据库的区别",tabindex:"-1"},[e("7、关系性数据库和非关系性数据库的区别 "),l("a",{class:"header-anchor",href:"#_7、关系性数据库和非关系性数据库的区别","aria-label":'Permalink to "7、关系性数据库和非关系性数据库的区别"'},"​")],-1),l("h4",{id:"数据组织方式",tabindex:"-1"},[e("数据组织方式 "),l("a",{class:"header-anchor",href:"#数据组织方式","aria-label":'Permalink to "数据组织方式"'},"​")],-1),l("p",null,"sql采用表格的形式组织数据，数据之间通过关系建立联系，可以一对一、一对多、多对多",-1),l("p",null,"nosql没有固定的关系，采用键值对的形式",-1),l("h4",{id:"数据一致性",tabindex:"-1"},[e("数据一致性 "),l("a",{class:"header-anchor",href:"#数据一致性","aria-label":'Permalink to "数据一致性"'},"​")],-1),l("p",null,"sql强调数据的一致性",-1),l("p",null,"nosql强调数据的可用性和分布式扩展性",-1),l("h3",{id:"_8、数据库事务",tabindex:"-1"},[e("8、数据库事务 "),l("a",{class:"header-anchor",href:"#_8、数据库事务","aria-label":'Permalink to "8、数据库事务"'},"​")],-1),l("h4",{id:"mysql如何支持事务",tabindex:"-1"},[e("mysql如何支持事务 "),l("a",{class:"header-anchor",href:"#mysql如何支持事务","aria-label":'Permalink to "mysql如何支持事务"'},"​")],-1),l("p",null,"通过innodb这样的一个支持ACID事务的存储引擎",-1),l("p",null,"ACID：原子性、一致性、隔离性、持久性",-1),l("p",null,"原子性：使用日志，如果操作失败，根据日志回滚到之前的状态",-1),l("p",null,"一致性：保证事务操作一致，事务开始前和结束后，数据库的状态一致",-1),l("p",null,"隔离性：使用锁实现。当一个事务执行时，其他事务无法访问该事务正在操作的数据，知道该事务结束并释放锁",-1),l("p",null,"持久性：使用日志记录事务的操作。数据库崩溃的情况，也可以通过回滚日志和重做日志来恢复数据",-1),l("h4",{id:"如何判断事务是否提交",tabindex:"-1"},[e("如何判断事务是否提交 "),l("a",{class:"header-anchor",href:"#如何判断事务是否提交","aria-label":'Permalink to "如何判断事务是否提交"'},"​")],-1),l("p",null,[e("查询系统变量"),l("code",null,"tx_isolation"),e("的值来判断当前事务的隔离级别")],-1),l("p",null,"使用commit命令执行或者查看事务日志",-1),l("h4",{id:"事务隔离级别",tabindex:"-1"},[e("事务隔离级别 "),l("a",{class:"header-anchor",href:"#事务隔离级别","aria-label":'Permalink to "事务隔离级别"'},"​")],-1),l("p",null,"为了解决并发问题，当多个并发事务执行的时候，确保数据的一致性，所划分的事务隔离级别",-1),l("p",null,"读未提交：最低级别，所有操作对其他事务可见，但导致脏读、不可重复读、幻读",-1),l("p",null,"读已提交：保证事务提交后，其他事务才能读到修改的数据，解决脏读的问题，但还有不可重复读和幻读",-1),l("p",null,"可重复读：事务执行期间多次读取到同一数据，得到结果相同，但导致幻读",-1),l("p",null,"串行化：强制事务串行执行，避免所有并发问题",-1),l("p",null,"脏读：读取到事务未提交的数据",-1),l("p",null,"不可重复读：事务多次读取同一数据，结果不一致",-1),l("p",null,"幻读：事务执行两次相同查询，结果不一致",-1),l("p",null,"解决方法：采用合适的事务隔离级别，使用乐观锁或悲观锁，修改时，减少锁定的范围",-1),l("h3",{id:"_9、数据量大的解决方案",tabindex:"-1"},[e("9、数据量大的解决方案 "),l("a",{class:"header-anchor",href:"#_9、数据量大的解决方案","aria-label":'Permalink to "9、数据量大的解决方案"'},"​")],-1),l("p",null,"1、垂直拆分：将大表拆分为多个小表",-1),l("p",null,"2、水平拆分：将数据分散到多个表中",-1),l("p",null,"3、数据库分区：大表拆成多个分区",-1),l("p",null,"4、数据库缓存：将不太更新但查询高的数据缓存到redis中",-1),l("p",null,"5、用合适的索引进行优化",-1),l("h3",{id:"_10、日志",tabindex:"-1"},[e("10、日志 "),l("a",{class:"header-anchor",href:"#_10、日志","aria-label":'Permalink to "10、日志"'},"​")],-1),l("h4",{id:"binlog",tabindex:"-1"},[e("binlog "),l("a",{class:"header-anchor",href:"#binlog","aria-label":'Permalink to "binlog"'},"​")],-1),l("p",null,"记录数据库增删改操作的日志文件，可以是用户直接对数据库进行的操作，也可以是系统自动进行的操作，如索引重建、数据库备份等",-1),l("p",null,"主要作用：",-1),l("p",null,"1、数据恢复：可以将数据库恢复到指定的时间点，以保证数据的完整性和可靠性。",-1),l("p",null,"2、数据复制：可以实现 MySQL 数据库的主从复制，将主库中的数据同步到从库中，以提高系统的可用性和性能。",-1),l("p",null,"3、数据分析：可以分析数据库中的操作记录，了解用户的行为和习惯，从而优化数据库的设计和性能。",-1),l("p",null,"4、安全审计：可以对数据库的操作进行监控和审计，防止非法操作和攻击。",-1),l("h4",{id:"redolog",tabindex:"-1"},[e("redolog "),l("a",{class:"header-anchor",href:"#redolog","aria-label":'Permalink to "redolog"'},"​")],-1),l("p",null,"保证数据的持久性。当数据被修改时，mysql会首先将修改操作记录到redolog中，然后再将数据更新到磁盘上。如果mysql崩了，可以通过redolog来恢复数据。",-1),l("h4",{id:"undolog",tabindex:"-1"},[e("undolog "),l("a",{class:"header-anchor",href:"#undolog","aria-label":'Permalink to "undolog"'},"​")],-1),l("p",null,"用于回滚事务。当一个事务被回滚时，会使用undolog中的数据将数据恢复到事务之前的状态",-1),l("p",null,"如何实现原子性：",-1),l("p",null,"1、事务开始时，InnoDB会为该事务分配一个Undo Log，并且在内存中创建一个Transaction ID（事务ID）",-1),l("p",null,"2、当事务执行UPDATE、DELETE、INSERT等修改数据的操作时，InnoDB会将修改前的数据记录到Undo Log中，这样就可以在事务回滚时恢复数据。",-1),l("p",null,"3、在事务提交之前，InnoDB会将所有修改操作记录到Redo Log中，并且将内存中的Transaction ID写入磁盘。",-1),l("p",null,"4、当事务回滚时，InnoDB会根据Undo Log中的数据恢复修改前的状态，并将Undo Log中的记录删除。",-1),l("p",null,"5、当系统崩溃时，InnoDB会根据Redo Log中的数据恢复修改后的状态，并根据Undo Log中的数据恢复修改前的状态，保证数据的一致性。",-1),l("h4",{id:"slow-query-log",tabindex:"-1"},[e("slow query log "),l("a",{class:"header-anchor",href:"#slow-query-log","aria-label":'Permalink to "slow query log"'},"​")],-1),l("p",null,"用于记录执行时间超过一定阈值的sql语句，用于优化数据库性能",-1),l("h4",{id:"error-log",tabindex:"-1"},[e("error log "),l("a",{class:"header-anchor",href:"#error-log","aria-label":'Permalink to "error log"'},"​")],-1),l("p",null,"用于记录 MySQL 的错误信息，包括 MySQL 启动和关闭过程中的错误信息以及运行时的错误信息",-1),l("h3",{id:"_11、定位慢查询-分析",tabindex:"-1"},[e("11、定位慢查询&分析 "),l("a",{class:"header-anchor",href:"#_11、定位慢查询-分析","aria-label":'Permalink to "11、定位慢查询&分析"'},"​")],-1),l("p",null,"一个接口测试非常慢，压测大约5秒钟",-1),l("p",null,"如何定位： 调试工具：Arthas",-1),l("h4",{id:"方案一",tabindex:"-1"},[e("方案一 "),l("a",{class:"header-anchor",href:"#方案一","aria-label":'Permalink to "方案一"'},"​")],-1),l("p",null,"mysql中开启慢查询日志 slow_query_log=1 如果是0就是没有开启",-1),l("p",null,"设置慢日志的时间 long_query_time=2",-1),l("p",null,"如果超过2s中的sql就会被记录到日志中",-1),l("h4",{id:"方案二",tabindex:"-1"},[e("方案二 "),l("a",{class:"header-anchor",href:"#方案二","aria-label":'Permalink to "方案二"'},"​")],-1),l("p",null,"使用explain命令查询sql语句执行计划",-1),l("p",null,"通过key和key_len检查是否命中了索引（索引本身是否会失效）",-1),l("p",null,"通过type字段查看sql是否有进一步的优化空间，是否存在全盘扫描或者全索引扫描",-1),l("p",null,"通过extra建议判断，是否出现了回表的情况。如果出现了，可以尝试添加索引或者返回字段来修复",-1),l("h3",{id:"_12、数据库三范式",tabindex:"-1"},[e("12、数据库三范式 "),l("a",{class:"header-anchor",href:"#_12、数据库三范式","aria-label":'Permalink to "12、数据库三范式"'},"​")],-1),l("p",null,"第一范式：强调列的原子性，每一列都是不可分割的原子数据项",-1),l("p",null,"第二范式：要求实体属性完全依赖于主关键字",-1),l("p",null,"第三范式：任何非主属性不依赖于其他非主属性",-1),l("h3",{id:"_13、数据库主从复制涉及到的线程",tabindex:"-1"},[e("13、数据库主从复制涉及到的线程 "),l("a",{class:"header-anchor",href:"#_13、数据库主从复制涉及到的线程","aria-label":'Permalink to "13、数据库主从复制涉及到的线程"'},"​")],-1),l("p",null,"主要涉及三个线程：binlog线程、I/O线程和sql线程",-1),l("p",null,"binlog线程：负责将主服务器上的数据更改写入二进制日志中",-1),l("p",null,"I/O线程：负责从主服务器上读取二进制日志，并重放其中的sql语句",-1),l("h3",{id:"_14、mysql8-0版本更新了哪些",tabindex:"-1"},[e("14、mysql8.0版本更新了哪些？ "),l("a",{class:"header-anchor",href:"#_14、mysql8-0版本更新了哪些","aria-label":'Permalink to "14、mysql8.0版本更新了哪些？"'},"​")],-1),l("p",null,"支持json数据",-1),l("p",null,"支持窗口函数",-1),l("p",null,"优化innodb-提高读写和并发性能",-1),l("p",null,"增强安全性（密码过期、可以进行加密网络数据传输）",-1),l("p",null,"自适应哈希索引",-1),l("h3",{id:"_15、mysql中死锁如何解决",tabindex:"-1"},[e("15、mysql中死锁如何解决 "),l("a",{class:"header-anchor",href:"#_15、mysql中死锁如何解决","aria-label":'Permalink to "15、mysql中死锁如何解决"'},"​")],-1),l("p",null,"是指两个或多个事务相互等待对方释放锁资源，导致事务无法继续执行的情况。",-1),l("p",null,"可以采用以下方法来解决死锁问题",-1),l("h4",{id:"手动回滚",tabindex:"-1"},[e("手动回滚 "),l("a",{class:"header-anchor",href:"#手动回滚","aria-label":'Permalink to "手动回滚"'},"​")],-1),l("p",null,"如果发生死锁，可以尝试手动回滚其中一个事务。",-1),l("p",null,"可以使用show engine innodb命令来查看当前死锁的状态，然后根据死锁信息中的事务ID手动回滚其中一个事务，以解除死锁",-1),l("h4",{id:"重启mysql",tabindex:"-1"},[e("重启mysql "),l("a",{class:"header-anchor",href:"#重启mysql","aria-label":'Permalink to "重启mysql"'},"​")],-1),l("p",null,"会导致所有事务被中断，同时也会释放所有锁资源",-1),l("h4",{id:"调整事务并发度",tabindex:"-1"},[e("调整事务并发度 "),l("a",{class:"header-anchor",href:"#调整事务并发度","aria-label":'Permalink to "调整事务并发度"'},"​")],-1),l("p",null,"如果死锁问题经常发生，可以考虑调整事务并发度来避免死锁",-1),l("h4",{id:"优化sql查询语句",tabindex:"-1"},[e("优化sql查询语句 "),l("a",{class:"header-anchor",href:"#优化sql查询语句","aria-label":'Permalink to "优化sql查询语句"'},"​")],-1),l("p",null,"可以使用索引来加速查询，或者避免使用长事务等方式来优化 SQL 查询语句",-1),l("h3",{id:"_16、myisam",tabindex:"-1"},[e("16、MyISAM "),l("a",{class:"header-anchor",href:"#_16、myisam","aria-label":'Permalink to "16、MyISAM"'},"​")],-1),l("h4",{id:"介绍",tabindex:"-1"},[e("介绍 "),l("a",{class:"header-anchor",href:"#介绍","aria-label":'Permalink to "介绍"'},"​")],-1),l("p",null,"支持主键索引、唯一索引、普通索引、全文索引",-1),l("p",null,"使用B树结构",-1),l("h4",{id:"选择-myisam的原因",tabindex:"-1"},[e("选择 MyISAM的原因 "),l("a",{class:"header-anchor",href:"#选择-myisam的原因","aria-label":'Permalink to "选择 MyISAM的原因"'},"​")],-1),l("p",null,"1、MyISAM 对于大量读操作和高并发读取性能较好，因为它采用表级锁定，而不是行级锁定。",-1),l("p",null,"2、MyISAM 对于存储和查询大量数据表时，可以占用比 InnoDB 更少的磁盘空间和内存，因为它不支持事务处理、外键约束和崩溃恢复等功能",-1),l("p",null,"3、MyISAM 的表结构相对简单，不支持事务处理和外键约束等复杂功能。",-1),l("h3",{id:"_17、评估mysql一张表可以存储多少数据",tabindex:"-1"},[e("17、评估mysql一张表可以存储多少数据 "),l("a",{class:"header-anchor",href:"#_17、评估mysql一张表可以存储多少数据","aria-label":'Permalink to "17、评估mysql一张表可以存储多少数据"'},"​")],-1),l("p",null,"1、数据行大小：每列",-1),l("h3",{id:"_1、常用sql语句-语法",tabindex:"-1"},[e("1、常用sql语句 语法 "),l("a",{class:"header-anchor",href:"#_1、常用sql语句-语法","aria-label":'Permalink to "1、常用sql语句 语法"'},"​")],-1),l("p",null,"1、查看当前数据库所有表",-1),l("p",null,"show tables；",-1),l("p",null,"2、查看表结构",-1),l("p",null,"desc 表名；",-1),l("p",null,"show create table classes；",-1),l("p",null,"3、",-1),l("p",null,"创建班级表",-1),l("p",null,"Create table class(",-1),l("p",null,"Id int unsigned primary key not null,",-1),l("p",null,"Name varchar(10)",-1),l("p",null,");",-1),l("p",null,"创建学生表",-1),l("p",null,"Create table students(",-1),l("p",null,"Id int unsigned primary key auto_increment not null,",-1),l("p",null,"Name varchar(20) default 0,",-1),l("p",null,"height decimal(5,2),",-1),l("p",null,"Gender enum('男','女','保密'),",-1),l("p",null,"Cls_id int unsigned default 0",-1),l("p",null,");",-1),l("p",null,"4、修改表 添加字段",-1),l("p",null,"Alter table 表名 add 列表 类型；",-1),l("p",null,"alter table students add birthday datetime;",-1),l("p",null,"Alter table 表名 change 原名 新名 类型及约束；",-1),l("p",null,"Alter table students change birthday birth date time not null;",-1),l("p",null,"alter table 表名 modify 列名 类型及约束；",-1),l("p",null,"alter table students modify birth date not null;",-1),l("p",null,"alter table 表名 drop 列名;",-1),l("p",null,"Alter table students drop birthday;",-1),l("p",null,"删除表",-1),l("p",null,"drop table students;",-1),l("p",null,"查看表的创建",-1),l("p",null,"show create table 表名；",-1),l("p",null,"Show create table classes;",-1),l("p",null,"查询所有列",-1),l("p",null,"Select * from 表名；",-1),l("p",null,"select * from classes;",-1),l("p",null,"查询指定列",-1),l("p",null,"select 列1，列2 … from 表名；",-1),l("p",null,"select id, name from classes;",-1),l("p",null,"增加",-1),l("p",null,"Insert into 表名 values(…)",-1),l("p",null,"Insert into students values(0,'guo',181,1,20);",-1),l("p",null,"Insert into students(name,birth) values('wang','2016-3-2');",-1),l("p",null,"修改",-1),l("p",null,"Update students set gender=2 where id=5;",-1),l("p",null,"删除",-1),l("p",null,"Delete from 表名 where 条件",-1),l("p",null,"Delete from students where id=5;",-1),l("p",null,"创建数据库",-1),l("p",null,"Create database python6 charset=utf8;",-1),l("p",null,"Use python7;",-1),l("p",null,"Select id as … from students",-1),l("p",null,"Select students.id,students.name,students.gender from students;",-1),l("p",null,"Select s.id,s.name,s.gender from students as s;",-1),l("p",null,"Select gender from students",-1),l("p",null,"查找编号大于3的学生",-1),l("p",null,"Select * from students where id>3;",-1),l("p",null,"查找编号不大于4的学生",-1),l("p",null,"Select * from students where id<=4;",-1),l("p",null,"查询姓名不是黄蓉的学生",-1),l("p",null,"Select * from students where name !='黄蓉';",-1),l("p",null,"查询没被删除的学生",-1),l("p",null,"Select * from students where is_delete=0;",-1),l("p",null,"查询姓黄的学生",-1),l("p",null,"select * from students where name like '黄%';",-1),l("p",null,"查询姓黄并且名是一个字的学生",-1),l("p",null,"select * from students where name like '黄_';",-1),l("p",null,"查询编号是1或3或8的学生",-1),l("p",null,"Select * from students where id in (1,3,8);",-1),l("p",null,"Select * from students where id between 3 and 8;",-1),l("p",null,"select * from students where id between 3 and 8 and gender=1;",-1),l("p",null,"Select * from students where height is null;",-1),l("p",null,"Select * from students where height is not null;",-1),l("p",null,"select * from students where height is not null and gender=1;",-1),l("p",null,"查询未删除男生信息，按学号降序",-1),l("p",null,"select * from students where gender=1 and is_delete=0 order by id desc;",-1),l("p",null,"查询未删除学生信息，按名称升序",-1),l("p",null,"Select * from students where is_delete=0 order by name;",-1),l("p",null,"显示所有的学生信息，按年龄从大到小排序，年龄相同按身高排序",-1),l("p",null,"select * from students order by age desc,height desc;",-1),l("p",null,"查询学生总数",-1),l("p",null,"select count(*) from students;",-1),l("p",null,"查询女生编号最大值",-1),l("p",null,"Select max(id) from students where gender=2;",-1),l("p",null,"查询未删除的学生最小编号",-1),l("p",null,"Select min(id) from students where is_delete=0;",-1),l("p",null,"查询男生的总年龄",-1),l("p",null,"Select sum(age) from students where gender=1;",-1),l("p",null,"查询未删除女生的编号平均值",-1),l("p",null,"Select avg(id) from students where is_delete=0 and gender=2;",-1),l("p",null,"Select gender from students group by gender;",-1),l("p",null,"分别统计性别为男/女的人年龄平均值",-1),l("p",null,"Select gender,avg(age) from students group by gender;",-1),l("p",null,"分别统计性别为男/女的人的个数",-1),l("p",null,"Select gender, count(*) from students group by gender;",-1),l("p",null,"查询前3行男生的信息",-1),l("p",null,"select * from students where gender=1 limit 0,3",-1),l("p",null,"使用内连接查询班级表与学生表",-1),l("p",null,"select * from students inner join classes on students.cls_id=class.id",-1),l("p",null,"使用左连接查询班级表与学生表",-1),l("p",null,"select * from students as s left join classes as c on s.cls_id=class.id",-1),l("p",null,"查询学生姓名和班级名称",-1),l("p",null,"Select s.name, c.name from students as s inner join classes as c on s.cls_id=c.id;",-1)])),"main-header":a(()=>[r(n.$slots,"main-header")]),"main-header-after":a(()=>[r(n.$slots,"main-header-after")]),"main-nav":a(()=>[r(n.$slots,"main-nav")]),"main-content-before":a(()=>[r(n.$slots,"main-content-before")]),"main-content":a(()=>[r(n.$slots,"main-content")]),"main-content-after":a(()=>[r(n.$slots,"main-content-after")]),"main-nav-before":a(()=>[r(n.$slots,"main-nav-before")]),"main-nav-after":a(()=>[r(n.$slots,"main-nav-after")]),comment:a(()=>[r(n.$slots,"comment")]),footer:a(()=>[r(n.$slots,"footer")]),aside:a(()=>[r(n.$slots,"aside")]),"aside-custom":a(()=>[r(n.$slots,"aside-custom")]),default:a(()=>[r(n.$slots,"default")]),_:3},8,["frontmatter"])}}};export{N as default,x as usePageData};
