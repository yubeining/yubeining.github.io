import{_ as b}from"./ValaxyMain.vue_vue_type_style_index_0_lang.DXFDIcRI.js";import{f as g,a as m,u as f}from"./chunks/vue-router.CE6eJGTm.js";import{O as v,a4 as n,V as r,U as a,X as e,u as k,P,A as _}from"./framework.CgPPQfmH.js";import"./app.2Hk-Pb-P.js";import"./chunks/dayjs.CCYrSalk.js";import"./chunks/vue-i18n.BoM8szIi.js";import"./chunks/pinia.BjFmakTL.js";import"./chunks/@vueuse/motion.Cp--YhDB.js";import"./chunks/nprogress.BahbDzmd.js";import"./YunComment.vue_vue_type_style_index_0_lang.DC8N30BB.js";import"./index.C5okkQwF.js";import"./YunPageHeader.vue_vue_type_script_setup_true_lang.PEAAi8W5.js";import"./post.CGlAV6UI.js";const x=g("/posts/study notes/java base knowledge/spring",async t=>JSON.parse('{"title":"spring","description":"","frontmatter":{"title":"spring","date":"2025-04-19","updated":"2025-04-19","categories":"java","tags":["java","笔记"],"top":1},"headers":[{"level":3,"title":"1、介绍spring框架","slug":"_1、介绍spring框架","link":"#_1、介绍spring框架","children":[]},{"level":3,"title":"2、AOP以及代理方式","slug":"_2、aop以及代理方式","link":"#_2、aop以及代理方式","children":[]},{"level":3,"title":"3、bean的生命周期","slug":"_3、bean的生命周期","link":"#_3、bean的生命周期","children":[]},{"level":3,"title":"4、bean的作用域","slug":"_4、bean的作用域","link":"#_4、bean的作用域","children":[]},{"level":3,"title":"5、spring框架中的设计模式","slug":"_5、spring框架中的设计模式","link":"#_5、spring框架中的设计模式","children":[]},{"level":3,"title":"6、IOC的工作流程","slug":"_6、ioc的工作流程","link":"#_6、ioc的工作流程","children":[]},{"level":3,"title":"7、循环依赖问题","slug":"_7、循环依赖问题","link":"#_7、循环依赖问题","children":[]},{"level":3,"title":"8、spring data","slug":"_8、spring-data","link":"#_8、spring-data","children":[]},{"level":3,"title":"9、spring事务（ACID）","slug":"_9、spring事务-acid","link":"#_9、spring事务-acid","children":[]},{"level":3,"title":"10、spring 常用注入方式","slug":"_10、spring-常用注入方式","link":"#_10、spring-常用注入方式","children":[]},{"level":3,"title":"11、spring配置文件","slug":"_11、spring配置文件","link":"#_11、spring配置文件","children":[]},{"level":3,"title":"12、IOC和DI的区别","slug":"_12、ioc和di的区别","link":"#_12、ioc和di的区别","children":[]},{"level":3,"title":"13、beanfactory的作用","slug":"_13、beanfactory的作用","link":"#_13、beanfactory的作用","children":[]},{"level":3,"title":"13、beandefinition的作用","slug":"_13、beandefinition的作用","link":"#_13、beandefinition的作用","children":[]},{"level":3,"title":"14、beanfactory和applicationContext的区别","slug":"_14、beanfactory和applicationcontext的区别","link":"#_14、beanfactory和applicationcontext的区别","children":[]},{"level":3,"title":"1、mvc模式 Model — View — Controler","slug":"_1、mvc模式-model-—-view-—-controler","link":"#_1、mvc模式-model-—-view-—-controler","children":[]},{"level":3,"title":"2、springmvc核心组件","slug":"_2、springmvc核心组件","link":"#_2、springmvc核心组件","children":[]},{"level":3,"title":"3、springmvc控制器的线程安全问题","slug":"_3、springmvc控制器的线程安全问题","link":"#_3、springmvc控制器的线程安全问题","children":[]},{"level":3,"title":"4、springmvc执行流程","slug":"_4、springmvc执行流程","link":"#_4、springmvc执行流程","children":[]},{"level":3,"title":"5、如何解决跨域问题","slug":"_5、如何解决跨域问题","link":"#_5、如何解决跨域问题","children":[]},{"level":3,"title":"1、如何配置和开启定时任务 @Scheduled注解","slug":"_1、如何配置和开启定时任务-scheduled注解","link":"#_1、如何配置和开启定时任务-scheduled注解","children":[]},{"level":3,"title":"2、介绍springboot","slug":"_2、介绍springboot","link":"#_2、介绍springboot","children":[]},{"level":3,"title":"1、SOA、分布式、微服务之间有什么关系和区别？","slug":"_1、soa、分布式、微服务之间有什么关系和区别","link":"#_1、soa、分布式、微服务之间有什么关系和区别","children":[]},{"level":3,"title":"2、微服务架构的使用情况","slug":"_2、微服务架构的使用情况","link":"#_2、微服务架构的使用情况","children":[]},{"level":3,"title":"3、常用微服务组件","slug":"_3、常用微服务组件","link":"#_3、常用微服务组件","children":[]},{"level":3,"title":"4、微服务中如何实现session共享","slug":"_4、微服务中如何实现session共享","link":"#_4、微服务中如何实现session共享","children":[]},{"level":3,"title":"5、如何实现服务注册和发现","slug":"_5、如何实现服务注册和发现","link":"#_5、如何实现服务注册和发现","children":[]},{"level":3,"title":"1、spring的常见注解","slug":"_1、spring的常见注解","link":"#_1、spring的常见注解","children":[]},{"level":3,"title":"2、springmvc常见注解","slug":"_2、springmvc常见注解","link":"#_2、springmvc常见注解","children":[]},{"level":3,"title":"3、springboot核心注解","slug":"_3、springboot核心注解","link":"#_3、springboot核心注解","children":[]},{"level":3,"title":"@autowired和@resource注解区别","slug":"autowired和-resource注解区别","link":"#autowired和-resource注解区别","children":[]}],"relativePath":"pages/posts/study notes/java base knowledge/spring.md","lastUpdated":1745542762000}'),{lazy:(t,o)=>t.name===o.name}),H={__name:"spring",setup(t,{expose:o}){var d;const{data:s}=x(),h=f(),p=m(),i=Object.assign(p.meta.frontmatter||{},((d=s.value)==null?void 0:d.frontmatter)||{});return p.meta.frontmatter=i,h.currentRoute.value.data=s.value,_("valaxy:frontmatter",i),globalThis.$frontmatter=i,o({frontmatter:{title:"spring",date:"2025-04-19",updated:"2025-04-19",categories:"java",tags:["java","笔记"],top:1}}),(l,c)=>{const u=b;return P(),v(u,{frontmatter:k(i)},{"main-content-md":n(()=>c[0]||(c[0]=[a("h1",{id:"spring",tabindex:"-1"},[e("Spring "),a("a",{class:"header-anchor",href:"#spring","aria-label":'Permalink to "Spring"'},"​")],-1),a("h3",{id:"_1、介绍spring框架",tabindex:"-1"},[e("1、介绍spring框架 "),a("a",{class:"header-anchor",href:"#_1、介绍spring框架","aria-label":'Permalink to "1、介绍spring框架"'},"​")],-1),a("h4",{id:"概念",tabindex:"-1"},[e("概念 "),a("a",{class:"header-anchor",href:"#概念","aria-label":'Permalink to "概念"'},"​")],-1),a("p",null,"spring：是整个生态，spring framework是整个spring生态的基石，为依赖注入、事务管理、web应用、数据访问等提供了核心支持。",-1),a("p",null,"特征是依赖注入",-1),a("p",null,"springboot：为快速启动且最小化配置的spring应用而设计，具有用于构建生产级别应用的一套固化的视图",-1),a("p",null,"通过一个自动配置和启动项解决了需要配置大量参数的问题",-1),a("p",null,"springcloud：是一整套基于springboot的微服务解决方案",-1),a("p",null,"springmvc：提供了一种分离式方法来开发web应用",-1),a("p",null,"bean：是指有spring容器管理的对象",-1),a("h4",{id:"为什么要使用spring呢-有哪些好处",tabindex:"-1"},[e("为什么要使用spring呢 有哪些好处 "),a("a",{class:"header-anchor",href:"#为什么要使用spring呢-有哪些好处","aria-label":'Permalink to "为什么要使用spring呢 有哪些好处"'},"​")],-1),a("p",null,"1、代码重用性：提供了bean的管理，AOP，bean可以通过注入的方式引用到其他bean中 提高代码复用率",-1),a("p",null,"2、配置性，通过配置文件或xml的方式定制应用",-1),a("p",null,"3、生态成熟，整合了很多其他开源技术库",-1),a("h4",{id:"优点",tabindex:"-1"},[e("优点 "),a("a",{class:"header-anchor",href:"#优点","aria-label":'Permalink to "优点"'},"​")],-1),a("p",null,"1、轻量：基本版本大约2MB",-1),a("p",null,"2、控制反转：Spring通过控制反转实现了松散耦合",-1),a("p",null,"3、面向切面编程（AOP）：支持面向切面编程，并且把应用业务逻辑和系统服务分开",-1),a("p",null,"4、容器：Spring包含并管理应用中对象的生命周期和配置",-1),a("p",null,"5、MVC框架：",-1),a("p",null,"6、事务管理：提供一个持续的事务管理接口，可以扩展到上⾄本地事务下⾄全局事务（JTA）。",-1),a("p",null,"7、异常处理：提供方便的API把具体技术相关的异常转化为一致的unchecked异常",-1),a("h3",{id:"_2、aop以及代理方式",tabindex:"-1"},[e("2、AOP以及代理方式 "),a("a",{class:"header-anchor",href:"#_2、aop以及代理方式","aria-label":'Permalink to "2、AOP以及代理方式"'},"​")],-1),a("h4",{id:"概念-1",tabindex:"-1"},[e("概念 "),a("a",{class:"header-anchor",href:"#概念-1","aria-label":'Permalink to "概念"'},"​")],-1),a("p",null,"面向切面编程。把系统分为两个部分：核心关注点和横切关注点。",-1),a("p",null,"业务处理的主要流程是核心关注点。权限认证、日志、事务处理等是横切关注点。",-1),a("p",null,"AOP作用在于把系统中的核心关注点和横切关注点分离开来",-1),a("h4",{id:"代理模式",tabindex:"-1"},[e("代理模式 "),a("a",{class:"header-anchor",href:"#代理模式","aria-label":'Permalink to "代理模式"'},"​")],-1),a("p",null,"AOP思想的实现一般基于代理模式。",-1),a("p",null,"java一般采用JDK动态代理，但是JDK动态代理只能代理接口而不能代理类。",-1),a("p",null,"因此，Spring AOP基于两种情况进行切换，Spring AOP同时支持CGLIB、ASPECTJ、JDK动态代理",-1),a("p",null,"1、如果目标对象的实现类实现了接口，采用JDK动态代理来生产AOP代理类",-1),a("p",null,"2、如果目标对象的实现类没有实现接口，采用CGLIB来生产AOP代理类",-1),a("h4",{id:"使用场景",tabindex:"-1"},[e("使用场景 "),a("a",{class:"header-anchor",href:"#使用场景","aria-label":'Permalink to "使用场景"'},"​")],-1),a("p",null,"日志记录、安全验证、事务管理、异常处理",-1),a("h4",{id:"如何使用",tabindex:"-1"},[e("如何使用 "),a("a",{class:"header-anchor",href:"#如何使用","aria-label":'Permalink to "如何使用"'},"​")],-1),a("p",null,"导入maven依赖、",-1),a("p",null,"定义切面类：使用注解@Before @after 或xml配置来声明",-1),a("p",null,"配置AOP代理、编写切点表达式",-1),a("h3",{id:"_3、bean的生命周期",tabindex:"-1"},[e("3、bean的生命周期 "),a("a",{class:"header-anchor",href:"#_3、bean的生命周期","aria-label":'Permalink to "3、bean的生命周期"'},"​")],-1),a("p",null,"从创建到销毁的整个过程 1、实例化：通过反射获取构造函数 2、属性赋值：解析自动装配 byname bytype constractor autowired 这个阶段解决了循环依赖的问题 3、初始化：调用xxxaware方法 调用初始化生命周期回调 如果bean实现aop 创建动态代理 4、销毁： 在spring容器关闭的时候进行调用 调用销毁生命周期回调",-1),a("h4",{id:"传统的java应用",tabindex:"-1"},[e("传统的java应用 "),a("a",{class:"header-anchor",href:"#传统的java应用","aria-label":'Permalink to "传统的java应用"'},"​")],-1),a("p",null,"生命周期很简单，使用java关键字new 进行 bean 的实例化，然后该bean就能够使用。bean不再使用时，进行垃圾回收",-1),a("h4",{id:"spring管理的bean",tabindex:"-1"},[e("spring管理的bean "),a("a",{class:"header-anchor",href:"#spring管理的bean","aria-label":'Permalink to "spring管理的bean"'},"​")],-1),a("p",null,"1、查找并加载需要被spring管理的bean，进行bean的实例化",-1),a("p",null,"2、容器根据使用的bean定义中的属性值和配置文件的属性值来设置bean实例中的属性，实现依赖注入",-1),a("p",null,"3、调用bean的初始化方法（1、处理@PostConstruct注解2、处理InitializingBean接口3、进行AOP）",-1),a("p",null,"4、容器关闭时，调用bean的销毁方法",-1),a("h4",{id:"bean的线程安全问题",tabindex:"-1"},[e("bean的线程安全问题 "),a("a",{class:"header-anchor",href:"#bean的线程安全问题","aria-label":'Permalink to "bean的线程安全问题"'},"​")],-1),a("p",null,"spring没有对bean做任何安全处理，在无状态时是线程安全的，但有状态的时候不是线程安全的",-1),a("p",null,"当多用户同时请求一个服务的时候，容器会给每一个请求分配一个线程，多个线程会并发执行该请求的业务逻辑。如果处理逻辑中有对该单列状态的修改，必须考虑线程同步问题",-1),a("p",null,"解决方法：",-1),a("p",null,"1、使用threadlocal",-1),a("p",null,"2、使用同步控制：synchronized关键字",-1),a("p",null,"3、使用线程安全的数据结构：concurrentHashMap",-1),a("h4",{id:"紧耦合和松耦合的区别",tabindex:"-1"},[e("紧耦合和松耦合的区别 "),a("a",{class:"header-anchor",href:"#紧耦合和松耦合的区别","aria-label":'Permalink to "紧耦合和松耦合的区别"'},"​")],-1),a("p",null,"紧耦合：类之间高度依赖 松耦合：通过促进单一职责和关注点分离、依赖倒置的设计原则来实现",-1),a("h3",{id:"_4、bean的作用域",tabindex:"-1"},[e("4、bean的作用域 "),a("a",{class:"header-anchor",href:"#_4、bean的作用域","aria-label":'Permalink to "4、bean的作用域"'},"​")],-1),a("p",null,"1、singleton : 唯⼀ bean 实例，Spring 中的 bean 默认都是单例的；",-1),a("p",null,"2、prototype : 每次请求都会创建⼀个新的 bean 实例；",-1),a("p",null,"3、request：每⼀次 HTTP 请求都会产⽣⼀个新的 bean，该 bean 仅在当前 HTTP request 内有效；",-1),a("p",null,"4、session : 每⼀次 HTTP 请求都会产⽣⼀个新的 bean，该 bean 仅在当前 HTTP session 内有效；",-1),a("p",null,"5、global-session：全局 session 作⽤域，仅仅在基于 portlet 的 web 应⽤中才有意义，Spring5 已经没有了。",-1),a("h3",{id:"_5、spring框架中的设计模式",tabindex:"-1"},[e("5、spring框架中的设计模式 "),a("a",{class:"header-anchor",href:"#_5、spring框架中的设计模式","aria-label":'Permalink to "5、spring框架中的设计模式"'},"​")],-1),a("p",null,"1、⼯⼚设计模式 : Spring 使⽤⼯⼚模式通过 BeanFactory、ApplicationContext 创建 bean 对象；",-1),a("p",null,"2、代理设计模式 : Spring AOP 功能的实现；",-1),a("p",null,"3、单例设计模式 : Spring 中的 Bean 默认都是单例的；",-1),a("p",null,"4、模板⽅法模式 : Spring 中 jdbcTemplate、hibernateTemplate 等以 Template 结尾的对数据库操作的类，它们就使⽤到了模板模式；",-1),a("p",null,"5、包装器设计模式 : 我们的项⽬需要连接多个数据库，⽽且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源；",-1),a("p",null,"6、观察者模式：Spring 事件驱动模型就是观察者模式很经典的⼀个应⽤；",-1),a("p",null,"7、适配器模式：Spring AOP 的增强或通知(Advice)使⽤到了适配器模式、SpringMVC 中也是⽤到了适配器模式适配 Controller。",-1),a("h3",{id:"_6、ioc的工作流程",tabindex:"-1"},[e("6、IOC的工作流程 "),a("a",{class:"header-anchor",href:"#_6、ioc的工作流程","aria-label":'Permalink to "6、IOC的工作流程"'},"​")],-1),a("p",null,"IOC控制反转，把对象的管理权限交给了容器，应用程序如果需要某个对象的实例，直接从IOC容器中获取 本来需要new Service 需要程序员自己创建，现在交给Spring的ioc去创建",-1),a("p",null,"优点：集中管理对象、方便维护、降低耦合度",-1),a("p",null,"工作流程：",-1),a("p",null,"1、配置文件加载：spring读取配置文件，根据配置文件内容来加载和实例化对象",-1),a("p",null,"2、实例化bean：根据配置文件中的信息实例化bean，创建对象并加入容器中进行管理",-1),a("p",null,"3、注入依赖：spring自动解析bean之间的依赖关系，并将依赖注入到对象中",-1),a("p",null,"4、生命周期管理：管理对象的生命周期，包括初始化、销毁操作",-1),a("p",null,"5、提供bean：提供了统一的接口，可以通过容器来获取bean的实例并使用",-1),a("p",null,"6、AOP增强：对bean进行增强和横向切面的功能",-1),a("h3",{id:"_7、循环依赖问题",tabindex:"-1"},[e("7、循环依赖问题 "),a("a",{class:"header-anchor",href:"#_7、循环依赖问题","aria-label":'Permalink to "7、循环依赖问题"'},"​")],-1),a("h4",{id:"问题",tabindex:"-1"},[e("问题 "),a("a",{class:"header-anchor",href:"#问题","aria-label":'Permalink to "问题"'},"​")],-1),a("p",null,"其实就是循环引用，两个或两个以上的bean互相持有对方，最终形成闭环",-1),a("h4",{id:"如何解决",tabindex:"-1"},[e("如何解决 "),a("a",{class:"header-anchor",href:"#如何解决","aria-label":'Permalink to "如何解决"'},"​")],-1),a("p",null,"通过三级缓存",-1),a("p",null,"第一级存储完整的bean实例对象，第二级缓存存储未初始化的bean，第三级缓存存储bean工厂，用来生成原始的bean对象，把bean的实例化和bean的依赖注入进行分离，通过不完整的bean实例解决单例循环依赖问题",-1),a("h4",{id:"构造方法出现循环依赖怎么解决",tabindex:"-1"},[e("构造方法出现循环依赖怎么解决 "),a("a",{class:"header-anchor",href:"#构造方法出现循环依赖怎么解决","aria-label":'Permalink to "构造方法出现循环依赖怎么解决"'},"​")],-1),a("p",null,"spring框架不能解决对构造函数的依赖注入，可以使用@lazy懒加载，什么时候需要对象再进行对bean对象的创建",-1),a("h3",{id:"_8、spring-data",tabindex:"-1"},[e("8、spring data "),a("a",{class:"header-anchor",href:"#_8、spring-data","aria-label":'Permalink to "8、spring data"'},"​")],-1),a("p",null,"是spring的一个子项目，用于简化数据库访问，支持nosql和关系数据存储。主要目标是使数据库的访问变得方便",-1),a("p",null,"特点：",-1),a("p",null,"springdata支持nosql存储：",-1),a("p",null,"mongodb文档数据库、neo4j图形数据库、redis键值存储、habase列族数据库",-1),a("p",null,"支持的sql",-1),a("p",null,"jdbc、jpa",-1),a("p",null,"springdata减少了数据访问层dao的开发量。开发者唯一要做的，就是声明持久层的接口。",-1),a("h3",{id:"_9、spring事务-acid",tabindex:"-1"},[e("9、spring事务（ACID） "),a("a",{class:"header-anchor",href:"#_9、spring事务-acid","aria-label":'Permalink to "9、spring事务（ACID）"'},"​")],-1),a("h4",{id:"事务特性",tabindex:"-1"},[e("事务特性 "),a("a",{class:"header-anchor",href:"#事务特性","aria-label":'Permalink to "事务特性"'},"​")],-1),a("p",null,"原子性：事务时最小的执行单位，不可分割。事务的原子性确保要么全部完成，要么完全不起作用",-1),a("p",null,"一致性：执行事务前后，数据保持一致",-1),a("p",null,"隔离性：并发访问数据库时，一个事务不被其他事务干扰，各并发事务之间是独立的",-1),a("p",null,"持久性：一个事务被提交之后，它对数据库中数据的改变是持久的",-1),a("h4",{id:"事务隔离级别",tabindex:"-1"},[e("事务隔离级别 "),a("a",{class:"header-anchor",href:"#事务隔离级别","aria-label":'Permalink to "事务隔离级别"'},"​")],-1),a("p",null,"多个事务同时执行时，事务之间互相隔离的程度",-1),a("p",null,"1、DEFAULT：使用数据库默认的事务隔离级别。",-1),a("p",null,"2、READ_UNCOMMITTED：最低的隔离级别，事务可以读取未提交的数据，可能导致脏读、不可重复读、幻读等问题。",-1),a("p",null,"3、READ_COMMITTED：事务只能读取已提交的数据，可以避免脏读问题，但可能导致不可重复读、幻读等问题。",-1),a("p",null,"4、REPEATABLE_READ：保证事务中查询的数据集合是一致的，可以避免脏读和不可重复读问题，但可能导致幻读问题。",-1),a("p",null,"5、SERIALIZABLE：最高的隔离级别，强制事务串行执行，避免脏读、不可重复读、幻读等问题，但可能导致性能下降。",-1),a("h4",{id:"如何实现事务",tabindex:"-1"},[e("如何实现事务 "),a("a",{class:"header-anchor",href:"#如何实现事务","aria-label":'Permalink to "如何实现事务"'},"​")],-1),a("p",null,"使用@transactioal注解实现的",-1),a("p",null,"本质是通过AOP完成，对方法前后进行拦截。执行方法前开启事务，在执行完目标方法后根据执行情况提交或者回滚事务。",-1),a("p",null,"spring创建一个代理对象作为bean，当调用代理对象方法时，有注解就用事务管理器创建一个数据库连接，并执行当前方法。没有异常就直接提交事务，出现异常则回滚事务",-1),a("p",null,"spring事务隔离级别对应的就是数据库的隔离级别",-1),a("p",null,"spring事务的传播机制是基于数据库连接的，一个数据库连接不同的事务",-1),a("h4",{id:"transactional底层原理",tabindex:"-1"},[e("@transactional底层原理 "),a("a",{class:"header-anchor",href:"#transactional底层原理","aria-label":'Permalink to "@transactional底层原理"'},"​")],-1),a("p",null,"使用动态代理来为标注@transactional注解的类和方法生成代理对象，从而拦截目标方法调用，并进行事务处理。提供两种代理JDK动态代理和CGLIB代理",-1),a("p",null,"使用了拦截器 负责在目标方法执行前后进行事务开启和提交",-1),a("p",null,"可以对jdbc等多个数据访问框架进行统一的事务管理",-1),a("p",null,"开启事务时可以设置事务的隔离级别",-1),a("h3",{id:"_10、spring-常用注入方式",tabindex:"-1"},[e("10、spring 常用注入方式 "),a("a",{class:"header-anchor",href:"#_10、spring-常用注入方式","aria-label":'Permalink to "10、spring 常用注入方式"'},"​")],-1),a("p",null,"1、构造器依赖注入：构造器依赖注入通过容器触发一个类的构造器来实现，该类有一系列参数，每个参数代表一个对其他类的依赖",-1),a("p",null,"2、Setter方法注入：Setter ⽅法注⼊是容器通过调⽤⽆参构造器或⽆参 static ⼯⼚⽅法实例化 bean 之后，调⽤该 bean 的 Setter ⽅法，即实现了基于 Setter 的依赖注⼊。",-1),a("p",null,"3、基于注解的注入：最好的解决⽅案是⽤构造器参数实现强制依赖，Setter ⽅法实现可选依赖",-1),a("h3",{id:"_11、spring配置文件",tabindex:"-1"},[e("11、spring配置文件 "),a("a",{class:"header-anchor",href:"#_11、spring配置文件","aria-label":'Permalink to "11、spring配置文件"'},"​")],-1),a("h4",{id:"xml配置文件",tabindex:"-1"},[e("xml配置文件 "),a("a",{class:"header-anchor",href:"#xml配置文件","aria-label":'Permalink to "xml配置文件"'},"​")],-1),a("p",null,"使用xml格式来描述应用程序的组件及其之间的关系",-1),a("p",null,"在xml配置文件中，可以定义bean、注入bean属性、配置切面、声明切面所需的通知等",-1),a("h4",{id:"注解配置文件",tabindex:"-1"},[e("注解配置文件 "),a("a",{class:"header-anchor",href:"#注解配置文件","aria-label":'Permalink to "注解配置文件"'},"​")],-1),a("p",null,"注解配置文件是在 Java 类中使用注解来配置应用程序的组件及其之间的关系。",-1),a("h3",{id:"_12、ioc和di的区别",tabindex:"-1"},[e("12、IOC和DI的区别 "),a("a",{class:"header-anchor",href:"#_12、ioc和di的区别","aria-label":'Permalink to "12、IOC和DI的区别"'},"​")],-1),a("p",null,"ioc：由spring来创建对象，维护对象的关系 di：spring注入才能实现控制反转，di是ioc的实现",-1),a("h3",{id:"_13、beanfactory的作用",tabindex:"-1"},[e("13、beanfactory的作用 "),a("a",{class:"header-anchor",href:"#_13、beanfactory的作用","aria-label":'Permalink to "13、beanfactory的作用"'},"​")],-1),a("p",null,"主要职责是生产bean，通过调用getBean传入标识生产一个bean",-1),a("h3",{id:"_13、beandefinition的作用",tabindex:"-1"},[e("13、beandefinition的作用 "),a("a",{class:"header-anchor",href:"#_13、beandefinition的作用","aria-label":'Permalink to "13、beandefinition的作用"'},"​")],-1),a("p",null,"主要负责存储bean的定义信息：决定bean的生产方式 比如根据xml文件来生产bean lazy，则不会在ioc加载的时候创建bean",-1),a("h3",{id:"_14、beanfactory和applicationcontext的区别",tabindex:"-1"},[e("14、beanfactory和applicationContext的区别 "),a("a",{class:"header-anchor",href:"#_14、beanfactory和applicationcontext的区别","aria-label":'Permalink to "14、beanfactory和applicationContext的区别"'},"​")],-1),a("p",null,"都可以管理bean的生命周期 applicationContext实现了beanfactory 不生产bean而是通知 factoryBean来进行生产 applicationContext 1、会自动帮我把配置的bean注册进来 2、加载环境变量 3、实现事件监听 4、注册很多对外扩展点 beanfactory 优点：内存占用率小",-1),a("h1",{id:"springmvc",tabindex:"-1"},[e("springmvc "),a("a",{class:"header-anchor",href:"#springmvc","aria-label":'Permalink to "springmvc"'},"​")],-1),a("h3",{id:"_1、mvc模式-model-—-view-—-controler",tabindex:"-1"},[e("1、mvc模式 Model — View — Controler "),a("a",{class:"header-anchor",href:"#_1、mvc模式-model-—-view-—-controler","aria-label":'Permalink to "1、mvc模式 Model — View — Controler"'},"​")],-1),a("p",null,"模型-视图-控制器，是springframework中的一个模块",-1),a("p",null,"model：程序主体部分。主要包含业务数据和业务逻辑，可拆分成拆分成业务层service和数据访问层repository。",-1),a("p",null,"view：呈现给用户的部分。可以支持不同的视图，比如fremark、velocity、jsp",-1),a("p",null,"controller：处理用户输入的数据。把传统mvc框架的controller控制器进行拆分，分成了前端控制器dispatcherservlet和后端控制器controller。",-1),a("h3",{id:"_2、springmvc核心组件",tabindex:"-1"},[e("2、springmvc核心组件 "),a("a",{class:"header-anchor",href:"#_2、springmvc核心组件","aria-label":'Permalink to "2、springmvc核心组件"'},"​")],-1),a("h4",{id:"前端控制器-dispatcherservlet",tabindex:"-1"},[a("strong",null,"前端控制器"),e(" DispatcherServlet "),a("a",{class:"header-anchor",href:"#前端控制器-dispatcherservlet","aria-label":'Permalink to "**前端控制器**  DispatcherServlet"'},"​")],-1),a("p",null,"Spring MVC的入口函数。",-1),a("p",null,"接受请求，响应结果，相当于转发器。",-1),a("p",null,"DispatcherServlet 是整个流程控制的中⼼，由它调⽤其它组件处理⽤户的请求",-1),a("h4",{id:"处理器映射器-handlermapping",tabindex:"-1"},[e("处理器映射器 HandlerMapping "),a("a",{class:"header-anchor",href:"#处理器映射器-handlermapping","aria-label":'Permalink to "处理器映射器 HandlerMapping"'},"​")],-1),a("p",null,"负责根据用户请求找到（Handler）Controller，SpringMVC提供了不同的映射器实现不同的映射方式",-1),a("h4",{id:"处理器适配器-handleradapter",tabindex:"-1"},[e("处理器适配器 HandlerAdapter "),a("a",{class:"header-anchor",href:"#处理器适配器-handleradapter","aria-label":'Permalink to "处理器适配器 HandlerAdapter"'},"​")],-1),a("p",null,"按照特定规则去执行Handler",-1),a("h4",{id:"处理器-handler",tabindex:"-1"},[e("处理器 Handler "),a("a",{class:"header-anchor",href:"#处理器-handler","aria-label":'Permalink to "处理器 Handler"'},"​")],-1),a("p",null,"后端控制器，在 DispatcherServlet 的控制下 Handler 对具体的⽤户请求进⾏处理。",-1),a("p",null,"需要工程师根据业务需求开发Handler",-1),a("h4",{id:"视图解析器-view-resolver",tabindex:"-1"},[e("视图解析器 view resolver "),a("a",{class:"header-anchor",href:"#视图解析器-view-resolver","aria-label":'Permalink to "视图解析器 view resolver"'},"​")],-1),a("p",null,"进⾏视图解析，根据逻辑视图名解析成真正的视图（View ）。",-1),a("p",null,"View Resolver 负责将处理结果⽣成 View 视图，View Resolver ⾸先根据逻辑视图名解析成物理视图名即具体的⻚⾯地址，再⽣成 View 视图对象，最后对View 进⾏渲染将处理结果通过⻚⾯展示给⽤户。",-1),a("h4",{id:"视图-view",tabindex:"-1"},[e("视图 view "),a("a",{class:"header-anchor",href:"#视图-view","aria-label":'Permalink to "视图 view"'},"​")],-1),a("p",null,"View 是⼀个接⼝，实现类⽀持不同的 View 类型（jsp、freemarker…）",-1),a("h3",{id:"_3、springmvc控制器的线程安全问题",tabindex:"-1"},[e("3、springmvc控制器的线程安全问题 "),a("a",{class:"header-anchor",href:"#_3、springmvc控制器的线程安全问题","aria-label":'Permalink to "3、springmvc控制器的线程安全问题"'},"​")],-1),a("p",null,"springmvc控制器是单例模式，所以存在线程安全问题",-1),a("h4",{id:"解决方案",tabindex:"-1"},[e("解决方案 "),a("a",{class:"header-anchor",href:"#解决方案","aria-label":'Permalink to "解决方案"'},"​")],-1),a("p",null,"1、避免使用共享的可变状态：不引入可变的实例变量，只依赖方法参数进行处理，可以避免线程安全问题的发生",-1),a("p",null,"2、使用方法局部变量：是线程私有的，不会收到并发访问的影响",-1),a("h3",{id:"_4、springmvc执行流程",tabindex:"-1"},[e("4、springmvc执行流程 "),a("a",{class:"header-anchor",href:"#_4、springmvc执行流程","aria-label":'Permalink to "4、springmvc执行流程"'},"​")],-1),a("p",null,"浏览器发送请求到前端服务器Dispatcher Servlet，Dispatcher Servlet根据请求到URL找到对应的Handler Mapping，Handler Mapping根据请求的URL找到对应的Controller，Controller执行业务逻辑处理 并返回ModelAndView，Dispatcher Servlet根据Controller返回的ModelAndView找到对应的View，View渲染数据，并返回给Dispatcher Servlet，Dispatcher Servlet将View返回给浏览器",-1),a("p",null,"前后端分离版本",-1),a("p",null,"1、用户发送请求到前端控制器DispatcherServlet",-1),a("p",null,"2、DispatcherServlet收到请求调用HandlerMapping",-1),a("p",null,"3、HandlerMapping找到具体的处理器，生成处理器对象及处理器拦截器，",-1),a("p",null,"再返回给DispatcherServlet",-1),a("p",null,"4、DispatcherServlet调用HandlerAdapter",-1),a("p",null,"5、handlerAdapter经过适配调用具体的处理器Controller",-1),a("p",null,"6、方法添加了@responseBody",-1),a("p",null,"7、通过HttpMessageConverter来返回结果转换为json并响应",-1),a("h3",{id:"_5、如何解决跨域问题",tabindex:"-1"},[e("5、如何解决跨域问题 "),a("a",{class:"header-anchor",href:"#_5、如何解决跨域问题","aria-label":'Permalink to "5、如何解决跨域问题"'},"​")],-1),a("p",null,"通过实现WebMvcConfigurer接⼝然后重写addCorsMappings方法",-1),a("h1",{id:"springboot",tabindex:"-1"},[e("SpringBoot "),a("a",{class:"header-anchor",href:"#springboot","aria-label":'Permalink to "SpringBoot"'},"​")],-1),a("h3",{id:"_1、如何配置和开启定时任务-scheduled注解",tabindex:"-1"},[e("1、如何配置和开启定时任务 @Scheduled注解 "),a("a",{class:"header-anchor",href:"#_1、如何配置和开启定时任务-scheduled注解","aria-label":'Permalink to "1、如何配置和开启定时任务 @Scheduled注解"'},"​")],-1),a("p",null,"1、maven引入spring boot starter Task的依赖",-1),a("p",null,"2、创建一个带有@Component或@Service注解的类",-1),a("p",null,"3、该类方法上添加@Scheduled注解",-1),a("p",null,"可以在指定时间内或间隔内自动执行任务",-1),a("h3",{id:"_2、介绍springboot",tabindex:"-1"},[e("2、介绍springboot "),a("a",{class:"header-anchor",href:"#_2、介绍springboot","aria-label":'Permalink to "2、介绍springboot"'},"​")],-1),a("p",null,"springboot框架是基于spring框架开发的，提供注解简化开发，避免了繁琐的配置和依赖管理，简化了spring应用程序开发的流程，也继承了spring的所有功能和API",-1),a("p",null,"spring组件一站式解决方案，简化了使用spring 的难度，节省了繁琐的配置，提供了各种启动器，开发者能快速上手。",-1),a("h4",{id:"核心配置文件",tabindex:"-1"},[e("核心配置文件 "),a("a",{class:"header-anchor",href:"#核心配置文件","aria-label":'Permalink to "核心配置文件"'},"​")],-1),a("p",null,"bootstrap.properties和application.properties",-1),a("p",null,"application：主要用于springboot项目的自动化配置",-1),a("p",null,"bootstrap：",-1),a("p",null,"有一些应用场景：使⽤ Spring Cloud Config 配置中⼼时，这时需要在 bootstrap 配置⽂件中添加连接到配置中⼼的配置属性来加载外部配置中⼼的配置信息；",-1),a("p",null,"⼀些固定的不能被覆盖的属性；",-1),a("p",null,"⼀些加密/解密的场景；",-1),a("h4",{id:"配置文件格式",tabindex:"-1"},[e("配置文件格式 "),a("a",{class:"header-anchor",href:"#配置文件格式","aria-label":'Permalink to "配置文件格式"'},"​")],-1),a("p",null,"properties 和 .yml，它们的区别主要是书写格式不同。",-1),a("p",null,"1、properties",-1),a("p",null,"app.user.name = javastack",-1),a("p",null,"2、yml",-1),a("p",null,"app: user: name: javastack",-1),a("p",null,"另外，.yml 格式不⽀持 @PropertySource 注解导⼊配置。",-1),a("p",null,"3、yaml",-1),a("p",null,"配置有序、支持数组，数组中的元素可以是基本数据类型也可以是对象",-1),a("h4",{id:"核心注解",tabindex:"-1"},[e("核心注解 "),a("a",{class:"header-anchor",href:"#核心注解","aria-label":'Permalink to "核心注解"'},"​")],-1),a("h4",{id:"springbootapplication",tabindex:"-1"},[e("@SpringBootApplication "),a("a",{class:"header-anchor",href:"#springbootapplication","aria-label":'Permalink to "@SpringBootApplication"'},"​")],-1),a("p",null,"标记一个类为应用程序的主类",-1),a("h4",{id:"包含以下三个注解",tabindex:"-1"},[e("包含以下三个注解 "),a("a",{class:"header-anchor",href:"#包含以下三个注解","aria-label":'Permalink to "包含以下三个注解"'},"​")],-1),a("h4",{id:"springbootconfiguration",tabindex:"-1"},[e("@SpringBootConfiguration "),a("a",{class:"header-anchor",href:"#springbootconfiguration","aria-label":'Permalink to "@SpringBootConfiguration"'},"​")],-1),a("p",null,"组合了@Configuration注解，实现配置文件的功能",-1),a("h4",{id:"enableautoconfiguration",tabindex:"-1"},[e("@EnableAutoConfiguration "),a("a",{class:"header-anchor",href:"#enableautoconfiguration","aria-label":'Permalink to "@EnableAutoConfiguration"'},"​")],-1),a("p",null,"实现自动配置。",-1),a("p",null,"@import会去读取该项目和该项目引用的jar包的classpath路径下",-1),a("p",null,"告知springboot去寻找并加载classpath路径下的所有META-INF/spring.factories配置文件中定义的自动配置类。然后Spring Boot根据这些自动配置类中的规则来自动配置应用程序中需要使用的各种Bean和依赖。",-1),a("h4",{id:"componentscan",tabindex:"-1"},[e("@ComponentScan "),a("a",{class:"header-anchor",href:"#componentscan","aria-label":'Permalink to "@ComponentScan"'},"​")],-1),a("p",null,"spring组件扫描",-1),a("h4",{id:"自动配置原理",tabindex:"-1"},[e("自动配置原理 "),a("a",{class:"header-anchor",href:"#自动配置原理","aria-label":'Permalink to "自动配置原理"'},"​")],-1),a("p",null,"导入非常多的自动配置类，给容器中导入这个场景需要的所有组件，并配置好这些组件，免去了手动编写配置注入功能组件等工作",-1),a("p",null,"给容器中自动配置类添加组件的时候，会从properties类中获取某些属性，只需要在配置文件中指定这些属性的值即可",-1),a("h4",{id:"不需要独立容器运行",tabindex:"-1"},[e("不需要独立容器运行 "),a("a",{class:"header-anchor",href:"#不需要独立容器运行","aria-label":'Permalink to "不需要独立容器运行"'},"​")],-1),a("p",null,"内置了tomcat、jetty容器",-1),a("h4",{id:"优点-1",tabindex:"-1"},[e("优点 "),a("a",{class:"header-anchor",href:"#优点-1","aria-label":'Permalink to "优点"'},"​")],-1),a("p",null,"1、内嵌各种servlet容器，Tomcat、jetty等，只要打成jar包就能独立运行，所有的依赖包都在jar包内",-1),a("p",null,"2、简化配置、自动配置，xml配置过程中无代码生成",-1),a("h4",{id:"springbootautoconfigure",tabindex:"-1"},[e("@springbootautoconfigure "),a("a",{class:"header-anchor",href:"#springbootautoconfigure","aria-label":'Permalink to "@springbootautoconfigure"'},"​")],-1),a("p",null,"包含许多针对springboot应用程序的自动配置类",-1),a("h4",{id:"_3、如何实现springboot应用程序的安全性",tabindex:"-1"},[e("3、如何实现springboot应用程序的安全性 "),a("a",{class:"header-anchor",href:"#_3、如何实现springboot应用程序的安全性","aria-label":'Permalink to "3、如何实现springboot应用程序的安全性"'},"​")],-1),a("p",null,"为了实现SpringBoot的安全性，我们使⽤spring-boot-starter-security依赖项，并且必须添加安全配置。它只需要很少的代码。配置类将必须扩WebSecurityConfigurerAdapter并覆盖其⽅法",-1),a("h4",{id:"_4、springbootstarterparent有什么用",tabindex:"-1"},[e("4、springbootstarterparent有什么用 "),a("a",{class:"header-anchor",href:"#_4、springbootstarterparent有什么用","aria-label":'Permalink to "4、springbootstarterparent有什么用"'},"​")],-1),a("p",null,"执行打包操作的配置、自动化的资源过滤、自动化的插件配置",-1),a("h1",{id:"springcloud",tabindex:"-1"},[e("SpringCloud "),a("a",{class:"header-anchor",href:"#springcloud","aria-label":'Permalink to "SpringCloud"'},"​")],-1),a("h3",{id:"_1、soa、分布式、微服务之间有什么关系和区别",tabindex:"-1"},[e("1、SOA、分布式、微服务之间有什么关系和区别？ "),a("a",{class:"header-anchor",href:"#_1、soa、分布式、微服务之间有什么关系和区别","aria-label":'Permalink to "1、SOA、分布式、微服务之间有什么关系和区别？"'},"​")],-1),a("p",null,"SOA和微服务都属于分布式架构。",-1),a("h4",{id:"soa",tabindex:"-1"},[e("SOA "),a("a",{class:"header-anchor",href:"#soa","aria-label":'Permalink to "SOA"'},"​")],-1),a("p",null,"服务划分更多是基于功能或业务，耦合度较高",-1),a("h4",{id:"微服务",tabindex:"-1"},[e("微服务 "),a("a",{class:"header-anchor",href:"#微服务","aria-label":'Permalink to "微服务"'},"​")],-1),a("p",null,"微服务的粒度更细，将系统拆分成一组更小、更独立的服务",-1),a("p",null,"更强调单一职责，将系统拆分为小而自治的服务，每个服务都可以独立开发、部署、扩展、替换",-1),a("p",null,"微服务架构更全面，SOA相当于只有注册中心的微服务架构",-1),a("h3",{id:"_2、微服务架构的使用情况",tabindex:"-1"},[e("2、微服务架构的使用情况 "),a("a",{class:"header-anchor",href:"#_2、微服务架构的使用情况","aria-label":'Permalink to "2、微服务架构的使用情况"'},"​")],-1),a("p",null,"从单体应用演变而来，当业务增多",-1),a("p",null,"分工协作：",-1),a("p",null,"单体项目、项目启动慢，拆分之后提高开发效率和敏捷性，单个服务启动快，每个人负责单独的模块",-1),a("p",null,"并发能力：",-1),a("p",null,"整体集群，易造成系统资源浪费。拆分后是服务集群，充分利用服务器资源，只需要针对下单服务进行压测就可以",-1),a("p",null,"业务：",-1),a("p",null,"单体业务维护困难，牵一发动全身。拆分后根据功能垂直拆分，责任更加分明，维护更加精准",-1),a("p",null,"容错：",-1),a("p",null,"单体：单点故障，一个功能OOM导致整个应用都不可用。拆分后，弱依赖的服务出现故障，可以进行熔断",-1),a("p",null,"拆分后的业务出现故障，可以进行熔断，依然不影响主业务正常使用",-1),a("p",null,"扩展：",-1),a("p",null,"单体难以技术升级，拆分后可以采用任意新技术",-1),a("p",null,"但会带来一些缺点：",-1),a("p",null,"分布式：远程调用速度很慢，面临失败的风险",-1),a("p",null,"最终一致性：很难保证强一致性",-1),a("p",null,"运维复杂性：",-1),a("p",null,"隐式接口：服务和服务通过接口来联系，当一个服务更改接口格式时，可能涉及到此接口的所有服务都需要做好调整",-1),a("h3",{id:"_3、常用微服务组件",tabindex:"-1"},[e("3、常用微服务组件 "),a("a",{class:"header-anchor",href:"#_3、常用微服务组件","aria-label":'Permalink to "3、常用微服务组件"'},"​")],-1),a("p",null,"springcloud alibaba",-1),a("p",null,"注册中心：Nacos、zookeeper （维护服务提供者的远程地址，管理服务）",-1),a("p",null,"负载均衡：ribbon （客户端的负载均衡器）",-1),a("p",null,"服务调用：openFeign dubbo （远程服务调用更加优雅）",-1),a("p",null,"配置中心：nacos config 管理服务的配置",-1),a("p",null,"服务熔断：sentinel 保持应用高可用 防止出现服务雪崩，防止激增流量打垮冷系统",-1),a("p",null,"分布式事务：seata 高性能微服务分布式事务解决方案",-1),a("p",null,"服务网关：spring cloud gateway 为客户端提供统一的服务，一些跟业务本身功能无关的公共逻辑都可以放在网关实现：鉴权、日志、限流、跨域、路由转发",-1),a("p",null,"链路追踪：skywalking 实时追踪服务的监控状况，协助快速恢复",-1),a("h3",{id:"_4、微服务中如何实现session共享",tabindex:"-1"},[e("4、微服务中如何实现session共享 "),a("a",{class:"header-anchor",href:"#_4、微服务中如何实现session共享","aria-label":'Permalink to "4、微服务中如何实现session共享"'},"​")],-1),a("p",null,"在不同微服务之间共享session，常见的方案是Spring session+redis来实现session共享",-1),a("p",null,"将所有微服务的session保存在redis上，当各个微服务对session有相关读写操作时，都去操作redis上的session",-1),a("h3",{id:"_5、如何实现服务注册和发现",tabindex:"-1"},[e("5、如何实现服务注册和发现 "),a("a",{class:"header-anchor",href:"#_5、如何实现服务注册和发现","aria-label":'Permalink to "5、如何实现服务注册和发现"'},"​")],-1),a("p",null,"服务注册：服务提供者需要把自己的信息注册到nacos，由nacos来保存这些信息，比如服务名称、IP、端口",-1),a("p",null,"服务发现：消费者向nacos拉取服务列表信息，如果服务提供者有集群，则消费者会利用负载均衡算法，选择一个发起调用",-1),a("p",null,"服务监控：服务提供者会每隔30s向nacos发送心跳，报告健康状态，没有接受到，则剔除",-1),a("h1",{id:"注解",tabindex:"-1"},[e("注解 "),a("a",{class:"header-anchor",href:"#注解","aria-label":'Permalink to "注解"'},"​")],-1),a("h3",{id:"_1、spring的常见注解",tabindex:"-1"},[e("1、spring的常见注解 "),a("a",{class:"header-anchor",href:"#_1、spring的常见注解","aria-label":'Permalink to "1、spring的常见注解"'},"​")],-1),a("p",null,"声明bean",-1),a("h4",{id:"component",tabindex:"-1"},[e("@Component "),a("a",{class:"header-anchor",href:"#component","aria-label":'Permalink to "@Component"'},"​")],-1),a("p",null,"可以将一个类声明为组件，表示是spring中的一个组件，可以通过依赖注入在其他组件中使用",-1),a("h4",{id:"service",tabindex:"-1"},[e("@Service "),a("a",{class:"header-anchor",href:"#service","aria-label":'Permalink to "@Service"'},"​")],-1),a("p",null,"用于标记一个服务类，表示业务逻辑层的组件，可以调用DAO层的代码来操作数据库",-1),a("h4",{id:"repository",tabindex:"-1"},[e("@Repository "),a("a",{class:"header-anchor",href:"#repository","aria-label":'Permalink to "@Repository"'},"​")],-1),a("p",null,"用于标识一个类是数据访问层的DAO组件，负责访问数据库或其他持久化存储介质。可以进行异常转换和自动装配",-1),a("h4",{id:"controller",tabindex:"-1"},[e("@controller "),a("a",{class:"header-anchor",href:"#controller","aria-label":'Permalink to "@controller"'},"​")],-1),a("p",null,"用于标记一个控制器类。表示mvc架构中的控制器组件，用于处理http请求和响应，返回视图或数据",-1),a("p",null,"依赖注入相关",-1),a("h4",{id:"autowired",tabindex:"-1"},[e("@autowired "),a("a",{class:"header-anchor",href:"#autowired","aria-label":'Permalink to "@autowired"'},"​")],-1),a("p",null,"spring会自动在容器中查找与该注解标记相同的bean，并将bean注入到变量中，可以用在构造函数、setter方法、字段上 ​注解的required属性默认为true表示必须找到相应的bean 否则抛出异常",-1),a("h4",{id:"resource",tabindex:"-1"},[e("@Resource "),a("a",{class:"header-anchor",href:"#resource","aria-label":'Permalink to "@Resource"'},"​")],-1),a("h4",{id:"scope",tabindex:"-1"},[e("@Scope "),a("a",{class:"header-anchor",href:"#scope","aria-label":'Permalink to "@Scope"'},"​")],-1),a("p",null,"设置作用域",-1),a("h4",{id:"configuration",tabindex:"-1"},[e("@Configuration "),a("a",{class:"header-anchor",href:"#configuration","aria-label":'Permalink to "@Configuration"'},"​")],-1),a("h4",{id:"componentscan-1",tabindex:"-1"},[e("@ComponentScan "),a("a",{class:"header-anchor",href:"#componentscan-1","aria-label":'Permalink to "@ComponentScan"'},"​")],-1),a("h4",{id:"bean",tabindex:"-1"},[e("@Bean "),a("a",{class:"header-anchor",href:"#bean","aria-label":'Permalink to "@Bean"'},"​")],-1),a("h3",{id:"_2、springmvc常见注解",tabindex:"-1"},[e("2、springmvc常见注解 "),a("a",{class:"header-anchor",href:"#_2、springmvc常见注解","aria-label":'Permalink to "2、springmvc常见注解"'},"​")],-1),a("h4",{id:"requestmapping",tabindex:"-1"},[e("@RequestMapping "),a("a",{class:"header-anchor",href:"#requestmapping","aria-label":'Permalink to "@RequestMapping"'},"​")],-1),a("p",null,"用于映射请求路径",-1),a("h4",{id:"requestparam",tabindex:"-1"},[e("@RequestParam "),a("a",{class:"header-anchor",href:"#requestparam","aria-label":'Permalink to "@RequestParam"'},"​")],-1),a("p",null,"参数绑定注解，用于绑定URL中的查询参数或请求体中的表单参数",-1),a("h4",{id:"requestbody",tabindex:"-1"},[e("@RequestBody "),a("a",{class:"header-anchor",href:"#requestbody","aria-label":'Permalink to "@RequestBody"'},"​")],-1),a("p",null,"参数绑定注解，用于绑定请求体中的JSON或XML格式的数据",-1),a("h4",{id:"postmapping",tabindex:"-1"},[e("@postmapping "),a("a",{class:"header-anchor",href:"#postmapping","aria-label":'Permalink to "@postmapping"'},"​")],-1),a("p",null,"将HTTP POST请求映射到特定的方法上，并将该请求映射到指定的URL上",-1),a("h4",{id:"getmapping",tabindex:"-1"},[e("@getmapping "),a("a",{class:"header-anchor",href:"#getmapping","aria-label":'Permalink to "@getmapping"'},"​")],-1),a("p",null,"将HTTP GET请求映射到特定的方法上，并将该请求映射到指定的URL上",-1),a("h3",{id:"_3、springboot核心注解",tabindex:"-1"},[e("3、springboot核心注解 "),a("a",{class:"header-anchor",href:"#_3、springboot核心注解","aria-label":'Permalink to "3、springboot核心注解"'},"​")],-1),a("h4",{id:"springbootapplication-1",tabindex:"-1"},[e("@springbootApplication "),a("a",{class:"header-anchor",href:"#springbootapplication-1","aria-label":'Permalink to "@springbootApplication"'},"​")],-1),a("p",null,"核心注解",-1),a("h3",{id:"autowired和-resource注解区别",tabindex:"-1"},[e("@autowired和@resource注解区别 "),a("a",{class:"header-anchor",href:"#autowired和-resource注解区别","aria-label":'Permalink to "@autowired和@resource注解区别"'},"​")],-1),a("p",null,"都是spring中实现的依赖注入",-1),a("p",null,"autowired默认根据类型实现注入",-1),a("p",null,"默认required=true",-1),a("p",null,"强制进行注入，如果没有这个bean，会报错",-1),a("p",null,"如果存在多个类型的bean实例，会导致注入失败",-1),a("p",null,"resource支持name type 两种注入方式",-1),a("p",null,"先根据name进行匹配，再根据type进行匹配",-1)])),"main-header":n(()=>[r(l.$slots,"main-header")]),"main-header-after":n(()=>[r(l.$slots,"main-header-after")]),"main-nav":n(()=>[r(l.$slots,"main-nav")]),"main-content-before":n(()=>[r(l.$slots,"main-content-before")]),"main-content":n(()=>[r(l.$slots,"main-content")]),"main-content-after":n(()=>[r(l.$slots,"main-content-after")]),"main-nav-before":n(()=>[r(l.$slots,"main-nav-before")]),"main-nav-after":n(()=>[r(l.$slots,"main-nav-after")]),comment:n(()=>[r(l.$slots,"comment")]),footer:n(()=>[r(l.$slots,"footer")]),aside:n(()=>[r(l.$slots,"aside")]),"aside-custom":n(()=>[r(l.$slots,"aside-custom")]),default:n(()=>[r(l.$slots,"default")]),_:3},8,["frontmatter"])}}};export{H as default,x as usePageData};
