import{_ as c}from"./ValaxyMain.vue_vue_type_style_index_0_lang.DXFDIcRI.js";import{f as b,a as k,u as f}from"./chunks/vue-router.CE6eJGTm.js";import{O as _,a4 as l,V as i,U as e,X as a,u as P,P as v,A as x}from"./framework.CgPPQfmH.js";import"./app.2Hk-Pb-P.js";import"./chunks/dayjs.CCYrSalk.js";import"./chunks/vue-i18n.BoM8szIi.js";import"./chunks/pinia.BjFmakTL.js";import"./chunks/@vueuse/motion.Cp--YhDB.js";import"./chunks/nprogress.BahbDzmd.js";import"./YunComment.vue_vue_type_style_index_0_lang.DC8N30BB.js";import"./index.C5okkQwF.js";import"./YunPageHeader.vue_vue_type_script_setup_true_lang.PEAAi8W5.js";import"./post.CGlAV6UI.js";const g=b("/posts/study notes/java base knowledge/redis",async s=>JSON.parse('{"title":"redis","description":"","frontmatter":{"title":"redis","date":"2025-04-19","updated":"2025-04-19","categories":"java","tags":["java","笔记"],"top":1},"headers":[{"level":3,"title":"1、内存淘汰策略","slug":"_1、内存淘汰策略","link":"#_1、内存淘汰策略","children":[]},{"level":3,"title":"2、持久化机制","slug":"_2、持久化机制","link":"#_2、持久化机制","children":[]},{"level":3,"title":"3、redis介绍","slug":"_3、redis介绍","link":"#_3、redis介绍","children":[]},{"level":3,"title":"5、redis集群","slug":"_5、redis集群","link":"#_5、redis集群","children":[]},{"level":3,"title":"6、redis速度快的原因","slug":"_6、redis速度快的原因","link":"#_6、redis速度快的原因","children":[]},{"level":3,"title":"7、redis线程安全","slug":"_7、redis线程安全","link":"#_7、redis线程安全","children":[]},{"level":3,"title":"8、redis和zk比较","slug":"_8、redis和zk比较","link":"#_8、redis和zk比较","children":[]},{"level":3,"title":"9、缓存的一些问题","slug":"_9、缓存的一些问题","link":"#_9、缓存的一些问题","children":[]},{"level":3,"title":"10、redis主从结构","slug":"_10、redis主从结构","link":"#_10、redis主从结构","children":[]},{"level":3,"title":"11、如何保证消费的幂等性","slug":"_11、如何保证消费的幂等性","link":"#_11、如何保证消费的幂等性","children":[]},{"level":3,"title":"12、如何保证redis高并发高可用","slug":"_12、如何保证redis高并发高可用","link":"#_12、如何保证redis高并发高可用","children":[]}],"relativePath":"pages/posts/study notes/java base knowledge/redis.md","lastUpdated":1745542762000}'),{lazy:(s,t)=>s.name===t.name}),T={__name:"redis",setup(s,{expose:t}){var h;const{data:d}=g(),u=f(),o=k(),n=Object.assign(o.meta.frontmatter||{},((h=d.value)==null?void 0:h.frontmatter)||{});return o.meta.frontmatter=n,u.currentRoute.value.data=d.value,x("valaxy:frontmatter",n),globalThis.$frontmatter=n,t({frontmatter:{title:"redis",date:"2025-04-19",updated:"2025-04-19",categories:"java",tags:["java","笔记"],top:1}}),(r,p)=>{const m=c;return v(),_(m,{frontmatter:P(n)},{"main-content-md":l(()=>p[0]||(p[0]=[e("h1",{id:"redis",tabindex:"-1"},[a("Redis "),e("a",{class:"header-anchor",href:"#redis","aria-label":'Permalink to "Redis"'},"​")],-1),e("h3",{id:"_1、内存淘汰策略",tabindex:"-1"},[a("1、内存淘汰策略 "),e("a",{class:"header-anchor",href:"#_1、内存淘汰策略","aria-label":'Permalink to "1、内存淘汰策略"'},"​")],-1),e("p",null,"LRU（最近最少使用）：优先淘汰最长时间未被使用的键",-1),e("p",null,"LFU（最不经常使用）：优先淘汰使用频率最低的键",-1),e("p",null,"TTL：为键设置过期时间，过期后自动淘汰",-1),e("p",null,"Maxmemory（最大内存限制）：当内存超出限制时，根据指定的淘汰策略进行淘汰",-1),e("h3",{id:"_2、持久化机制",tabindex:"-1"},[a("2、持久化机制 "),e("a",{class:"header-anchor",href:"#_2、持久化机制","aria-label":'Permalink to "2、持久化机制"'},"​")],-1),e("h4",{id:"rdb",tabindex:"-1"},[a("RDB "),e("a",{class:"header-anchor",href:"#rdb","aria-label":'Permalink to "RDB"'},"​")],-1),e("p",null,"把内存中所有数据记录到磁盘中，当redis实例故障重启后，从磁盘读取快照文件，恢复数据。",-1),e("p",null,"快照文件称为RDB文件，默认是保存在当前运行目录。",-1),e("h4",{id:"aof",tabindex:"-1"},[a("AOF "),e("a",{class:"header-anchor",href:"#aof","aria-label":'Permalink to "AOF"'},"​")],-1),e("p",null,"AOF持久化，redis处理的每一个写命令都会记录在AOF文件，可以看作命令日志文件",-1),e("p",null,"同时启用时，redis优先加载AOF文件来恢复数据，如果AOF文件不存在，则会尝试加载RDB文件",-1),e("h4",{id:"对比",tabindex:"-1"},[a("对比 "),e("a",{class:"header-anchor",href:"#对比","aria-label":'Permalink to "对比"'},"​")],-1),e("p",null,"RDB定时对整个内存做快照，AOF记录每一次执行的命令。",-1),e("p",null,"RDB恢复速度很快但是消耗很多内存和大量CPU占用，AOF主要是磁盘IO资源",-1),e("p",null,"RDB可以容忍数据丢失，AOF对数据安全性要求较高",-1),e("h4",{id:"如何实现数据尽可能少丢失又能兼顾性能",tabindex:"-1"},[a("如何实现数据尽可能少丢失又能兼顾性能 "),e("a",{class:"header-anchor",href:"#如何实现数据尽可能少丢失又能兼顾性能","aria-label":'Permalink to "如何实现数据尽可能少丢失又能兼顾性能"'},"​")],-1),e("p",null,"redis重启时，先加载RDB中的内容，然后再重放增量AOF日志，替代之前的AOF全量文件重放",-1),e("h3",{id:"_3、redis介绍",tabindex:"-1"},[a("3、redis介绍 "),e("a",{class:"header-anchor",href:"#_3、redis介绍","aria-label":'Permalink to "3、redis介绍"'},"​")],-1),e("h4",{id:"概念",tabindex:"-1"},[a("概念 "),e("a",{class:"header-anchor",href:"#概念","aria-label":'Permalink to "概念"'},"​")],-1),e("p",null,"redis是分布式的缓存中间件，是基于内存实现的kv数据结构的nosql数据库",-1),e("p",null,"因为是内存存储，所以读写速度非常快，也需要将数据持久化到磁盘上，避免数据丢失",-1),e("h4",{id:"数据结构",tabindex:"-1"},[a("数据结构 "),e("a",{class:"header-anchor",href:"#数据结构","aria-label":'Permalink to "数据结构"'},"​")],-1),e("h4",{id:"字符串-string",tabindex:"-1"},[a("字符串(string) "),e("a",{class:"header-anchor",href:"#字符串-string","aria-label":'Permalink to "字符串(string)"'},"​")],-1),e("p",null,"键值对，支持各种二进制数据，简单高效。",-1),e("p",null,"适用场景：缓存、计数器、分布式锁、共享session、限速",-1),e("h4",{id:"哈希表-hash",tabindex:"-1"},[a("哈希表(hash) "),e("a",{class:"header-anchor",href:"#哈希表-hash","aria-label":'Permalink to "哈希表(hash)"'},"​")],-1),e("p",null,"键值对集合、用来存储多个值",-1),e("p",null,"适用场景：缓存、存储商品信息、用户信息",-1),e("h4",{id:"列表-list",tabindex:"-1"},[a("列表(list) "),e("a",{class:"header-anchor",href:"#列表-list","aria-label":'Permalink to "列表(list)"'},"​")],-1),e("p",null,"有序的字符串列表、每个元素都是字符串。",-1),e("p",null,"可以在列表两端添加或删除元素，支持各种列表操作，比如插入、删除、查找。",-1),e("p",null,"适用场景：消息队列",-1),e("h4",{id:"集合-set",tabindex:"-1"},[a("集合(set) "),e("a",{class:"header-anchor",href:"#集合-set","aria-label":'Permalink to "集合(set)"'},"​")],-1),e("p",null,"无序的字符串集合",-1),e("p",null,"可以添加、删除、查找元素，支持各种集合操作",-1),e("p",null,"适用场景：共同爱好",-1),e("h4",{id:"有序集合-sorted-set",tabindex:"-1"},[a("有序集合(sorted set) "),e("a",{class:"header-anchor",href:"#有序集合-sorted-set","aria-label":'Permalink to "有序集合(sorted set)"'},"​")],-1),e("p",null,"有序的字符串集合",-1),e("p",null,"适用场景：排行榜",-1),e("p",null,"支持分布式存储，可以将数据分散到多个节点上",-1),e("p",null,"支持高并发性，多个客户端可以同时访问",-1),e("h4",{id:"通过expire来设置key的过期时间",tabindex:"-1"},[a("通过expire来设置key的过期时间 "),e("a",{class:"header-anchor",href:"#通过expire来设置key的过期时间","aria-label":'Permalink to "通过expire来设置key的过期时间"'},"​")],-1),e("p",null,"定时去清理过期的缓存",-1),e("p",null,"有用户请求过来时，再判断这个请求所用到的缓存是否过期，过期就去底层系统得到新数据并更新缓存",-1),e("h3",{id:"_5、redis集群",tabindex:"-1"},[a("5、redis集群 "),e("a",{class:"header-anchor",href:"#_5、redis集群","aria-label":'Permalink to "5、redis集群"'},"​")],-1),e("p",null,"是一种分布式部署方式，解决单机redis无法满足高并发和数据量大的场景",-1),e("p",null,"有三种方案：主从复制、哨兵模式、redis分片集群",-1),e("h4",{id:"主从同步",tabindex:"-1"},[a("主从同步 "),e("a",{class:"header-anchor",href:"#主从同步","aria-label":'Permalink to "主从同步"'},"​")],-1),e("p",null,"单节点redis并发能力是有上限的，要进一步提高redis并发能力，可以搭建主从集群，实现读写分离。一般是一主多从，主节点负责写数据，从节点负责读数据。主节点写入数据之后，需要把数据同步到从节点中",-1),e("p",null,"第一次建立连接，全量同步。第二次建立连接，增量同步",-1),e("p",null,"slave建立同步的操作，请求master数据同步，判断是否是第一次",-1),e("p",null,"master执行bgsave，生成RDB，发送RDB文件",-1),e("p",null,"增量同步：后续去repl_balog中获取offset的数据",-1),e("h4",{id:"工作原理",tabindex:"-1"},[a("工作原理 "),e("a",{class:"header-anchor",href:"#工作原理","aria-label":'Permalink to "工作原理"'},"​")],-1),e("p",null,"使用数据分片，每个节点存储部分数据，让数据分散到各个节点上",-1),e("p",null,"每个节点有多个复制节点，主节点负责处理客户端请求，数据复制到从节点上",-1),e("p",null,"从节点负责数据备份，当主节点失效时接替主节点",-1),e("h4",{id:"优点",tabindex:"-1"},[a("优点 "),e("a",{class:"header-anchor",href:"#优点","aria-label":'Permalink to "优点"'},"​")],-1),e("p",null,"方便进行横向扩展，增加新的节点即可增加系统的处理能力",-1),e("p",null,"可以自动将数据分散到各个节点上，数据分布均衡",-1),e("p",null,"各个节点可以并行处理请求，提高系统的并发能力",-1),e("h4",{id:"哨兵机制",tabindex:"-1"},[a("哨兵机制 "),e("a",{class:"header-anchor",href:"#哨兵机制","aria-label":'Permalink to "哨兵机制"'},"​")],-1),e("p",null,"实现主从集群的自动故障恢复",-1),e("p",null,"如果master故障，哨兵会将一个slave提升为master。当故障实例恢复后也以新的master为主",-1),e("h3",{id:"_6、redis速度快的原因",tabindex:"-1"},[a("6、redis速度快的原因 "),e("a",{class:"header-anchor",href:"#_6、redis速度快的原因","aria-label":'Permalink to "6、redis速度快的原因"'},"​")],-1),e("p",null,"1、数据基于内存存储，读写快，没有磁盘IO开销",-1),e("p",null,"2、单线程模型，所有命令都是在一个线程中执行，避免线程切换的开销",-1),e("p",null,"3、异步的非阻塞IO模型，大量并发连接不降低性能",-1),e("h3",{id:"_7、redis线程安全",tabindex:"-1"},[a("7、redis线程安全 "),e("a",{class:"header-anchor",href:"#_7、redis线程安全","aria-label":'Permalink to "7、redis线程安全"'},"​")],-1),e("p",null,"redis本身是一个线程安全的kv数据库，因为redis的设计和实现采用了单线程模型",-1),e("p",null,"在单线程模型下，通过使用非阻塞I/O和事件循环机制，使得单个线程能够高效地处理大量的并发请求。",-1),e("p",null,"但是作为缓存或数据库等存储服务时，应用程序自身仍然需要考虑并发访问的线程安全性",-1),e("p",null,"但是如果有多个redis客户端同时执行操作指令，就无法保证原子性。可以对多个客户端的访问进行加锁",-1),e("h4",{id:"引入多线程",tabindex:"-1"},[a("引入多线程 "),e("a",{class:"header-anchor",href:"#引入多线程","aria-label":'Permalink to "引入多线程"'},"​")],-1),e("p",null,"redis的性能瓶颈主要来源于网络IO",-1),e("p",null,"多线程任务可以分摊redis同步IO读写负荷",-1),e("h4",{id:"多线程实现机制",tabindex:"-1"},[a("多线程实现机制 "),e("a",{class:"header-anchor",href:"#多线程实现机制","aria-label":'Permalink to "多线程实现机制"'},"​")],-1),e("p",null,"主线程负责接收建立连接请求，获取socket放入全局等待处理队列",-1),e("p",null,"主线程处理完读事件后，通过RR将这些连接分配给这些IO进程",-1),e("p",null,"主线程阻塞等待IO线程读取socket完毕",-1),e("h3",{id:"_8、redis和zk比较",tabindex:"-1"},[a("8、redis和zk比较 "),e("a",{class:"header-anchor",href:"#_8、redis和zk比较","aria-label":'Permalink to "8、redis和zk比较"'},"​")],-1),e("p",null,"redis可以用setnx来实现分布式锁，zk可以基于同一级节点的唯一性或者有序节点的特性来实现分布式锁",-1),e("p",null,"由于redis读写性能比zk更好，在高并发场景中，zk实现分布式锁会存在性能瓶颈。所以redis更好",-1),e("h3",{id:"_9、缓存的一些问题",tabindex:"-1"},[a("9、缓存的一些问题 "),e("a",{class:"header-anchor",href:"#_9、缓存的一些问题","aria-label":'Permalink to "9、缓存的一些问题"'},"​")],-1),e("h4",{id:"mysql和redis数据一致性",tabindex:"-1"},[a("mysql和redis数据一致性 "),e("a",{class:"header-anchor",href:"#mysql和redis数据一致性","aria-label":'Permalink to "mysql和redis数据一致性"'},"​")],-1),e("p",null,"redis是实现应用和mysql之间的一个读操作缓存层",-1),e("p",null,"命中缓存，从缓存中读取数据并返回前端",-1),e("p",null,"没有命中缓存，从数据库中加载数据返回前端，并写入redis中",-1),e("p",null,"方法：",-1),e("p",null,"采用主动更新的策略",-1),e("p",null,"先更新数据库，再删除缓存",-1),e("p",null,"极端情况下，使用最终一致性方案：",-1),e("p",null,"基于rocketMQ的可靠性消息通信、canal组件监控mysql中binlog日志，把更新后的数据同步到redis中",-1),e("h4",{id:"缓存击穿",tabindex:"-1"},[a("缓存击穿 "),e("a",{class:"header-anchor",href:"#缓存击穿","aria-label":'Permalink to "缓存击穿"'},"​")],-1),e("p",null,"某一个key",-1),e("p",null,"对于设置过期时间key，缓存在某个时间点过期的时候，恰好有大量的并发请求，把数据库打挂",-1),e("p",null,"解决方法：",-1),e("p",null,"1、使用互斥锁：当缓存失效时，不立即去加载数据库，先设置一个互斥锁，当操作成功返回时再去进行加载数据库的操作并回设缓存",-1),e("p",null,"2、设置当前key逻辑过期：设置一个过期时间字段存入缓存，不给当前key设置过期时间，当查询的时候，从redis取出数据后判断时间是否过期，过期则开通另一个线程进行同步，当前线程正常返回数据，这个数据不是最新",-1),e("h4",{id:"缓存穿透",tabindex:"-1"},[a("缓存穿透 "),e("a",{class:"header-anchor",href:"#缓存穿透","aria-label":'Permalink to "缓存穿透"'},"​")],-1),e("p",null,"查询一个不存在的数据，未命中缓存，每次都去数据库中查找",-1),e("p",null,"解决方法：",-1),e("p",null,"1、缓存空对象：",-1),e("p",null,"使用空值作为缓存",-1),e("p",null,"但是如果添加了该数据，缓存和存储的数据可能不一致",-1),e("p",null,"2、布隆过滤器",-1),e("p",null,"底层是一个大的数组，存放0或1.初始化为0",-1),e("p",null,"当一个key来了之后经过3次hash计算，标明一个key 的存在",-1),e("p",null,"但是会存在一个误判率5%",-1),e("h4",{id:"缓存雪崩",tabindex:"-1"},[a("缓存雪崩 "),e("a",{class:"header-anchor",href:"#缓存雪崩","aria-label":'Permalink to "缓存雪崩"'},"​")],-1),e("p",null,"大量的key",-1),e("p",null,"缓存集中在一段时间内失效",-1),e("p",null,"解决方法：",-1),e("p",null,"1、给过期时间加一个随机值",-1),e("p",null,"2、通过加锁或队列来控制数据库中写缓存的线程数量",-1),e("h3",{id:"_10、redis主从结构",tabindex:"-1"},[a("10、redis主从结构 "),e("a",{class:"header-anchor",href:"#_10、redis主从结构","aria-label":'Permalink to "10、redis主从结构"'},"​")],-1),e("p",null,"因为单节点redis并发能力有上限的，要进一步提高redis并发能力，就要搭建主从集群，实现读写分离",-1),e("p",null,"第一次建立连接的时候采用全量同步，其他大多数时候采用增量同步",-1),e("p",null,"如果repild相同，是全量同步，master将完整内存数据生成RDB，发送RDB到slave，slave清空本地数据，加载master的RDB",-1),e("p",null,"repild不同的话，做增量同步，salve与master的offset之间的差异，就是salve需要增量拷贝的数据",-1),e("h4",{id:"主从复制原理",tabindex:"-1"},[a("主从复制原理 "),e("a",{class:"header-anchor",href:"#主从复制原理","aria-label":'Permalink to "主从复制原理"'},"​")],-1),e("h3",{id:"_11、如何保证消费的幂等性",tabindex:"-1"},[a("11、如何保证消费的幂等性 "),e("a",{class:"header-anchor",href:"#_11、如何保证消费的幂等性","aria-label":'Permalink to "11、如何保证消费的幂等性"'},"​")],-1),e("p",null,"无论重复请求多少次，得到的结果都是一样的",-1),e("p",null,"1、写数据时，先根据主键查一下这条数据是否存在，如果已存在则update",-1),e("p",null,"2、数据库的唯一键约束也可以保证不会重复插入多条",-1),e("p",null,"3、写入redis，就没有问题 setnx操作是天然幂等性的",-1),e("p",null,"无论使用什么操作，只有两种方法：接口只允许调用一次，比如唯一约束、基于redis的锁机制；对数据的影响只会触发一次，比如状态机、乐观锁",-1),e("h3",{id:"_12、如何保证redis高并发高可用",tabindex:"-1"},[a("12、如何保证redis高并发高可用 "),e("a",{class:"header-anchor",href:"#_12、如何保证redis高并发高可用","aria-label":'Permalink to "12、如何保证redis高并发高可用"'},"​")],-1),e("p",null,"主从集群+哨兵模式",-1),e("p",null,"哨兵可以实现主从集群的自动故障恢复",-1)])),"main-header":l(()=>[i(r.$slots,"main-header")]),"main-header-after":l(()=>[i(r.$slots,"main-header-after")]),"main-nav":l(()=>[i(r.$slots,"main-nav")]),"main-content-before":l(()=>[i(r.$slots,"main-content-before")]),"main-content":l(()=>[i(r.$slots,"main-content")]),"main-content-after":l(()=>[i(r.$slots,"main-content-after")]),"main-nav-before":l(()=>[i(r.$slots,"main-nav-before")]),"main-nav-after":l(()=>[i(r.$slots,"main-nav-after")]),comment:l(()=>[i(r.$slots,"comment")]),footer:l(()=>[i(r.$slots,"footer")]),aside:l(()=>[i(r.$slots,"aside")]),"aside-custom":l(()=>[i(r.$slots,"aside-custom")]),default:l(()=>[i(r.$slots,"default")]),_:3},8,["frontmatter"])}}};export{T as default,g as usePageData};
