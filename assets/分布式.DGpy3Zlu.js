import{_ as c}from"./ValaxyMain.vue_vue_type_style_index_0_lang.DXFDIcRI.js";import{f,a as b,u as k}from"./chunks/vue-router.CE6eJGTm.js";import{O as g,a4 as l,V as t,U as a,X as e,u as P,P as v,A as _}from"./framework.CgPPQfmH.js";import"./app.2Hk-Pb-P.js";import"./chunks/dayjs.CCYrSalk.js";import"./chunks/vue-i18n.BoM8szIi.js";import"./chunks/pinia.BjFmakTL.js";import"./chunks/@vueuse/motion.Cp--YhDB.js";import"./chunks/nprogress.BahbDzmd.js";import"./YunComment.vue_vue_type_style_index_0_lang.DC8N30BB.js";import"./index.C5okkQwF.js";import"./YunPageHeader.vue_vue_type_script_setup_true_lang.PEAAi8W5.js";import"./post.CGlAV6UI.js";const $=f("/posts/study notes/java base knowledge/分布式",async s=>JSON.parse('{"title":"分布式","description":"","frontmatter":{"title":"分布式","date":"2025-04-19","updated":"2025-04-19","categories":"java","tags":["java","笔记"],"top":1},"headers":[{"level":3,"title":"1、分布式锁","slug":"_1、分布式锁","link":"#_1、分布式锁","children":[]},{"level":3,"title":"2、分布式事务","slug":"_2、分布式事务","link":"#_2、分布式事务","children":[]},{"level":3,"title":"3、CAP理论和BASE理论","slug":"_3、cap理论和base理论","link":"#_3、cap理论和base理论","children":[]},{"level":3,"title":"4、如何设计一个分布式系统","slug":"_4、如何设计一个分布式系统","link":"#_4、如何设计一个分布式系统","children":[]},{"level":3,"title":"5、seata架构","slug":"_5、seata架构","link":"#_5、seata架构","children":[]},{"level":3,"title":"6、分布式事务解决方案","slug":"_6、分布式事务解决方案","link":"#_6、分布式事务解决方案","children":[]}],"relativePath":"pages/posts/study notes/java base knowledge/分布式.md","lastUpdated":1745542762000}'),{lazy:(s,i)=>s.name===i.name}),w={__name:"分布式",setup(s,{expose:i}){var p;const{data:o}=$(),u=k(),d=b(),r=Object.assign(d.meta.frontmatter||{},((p=o.value)==null?void 0:p.frontmatter)||{});return d.meta.frontmatter=r,u.currentRoute.value.data=o.value,_("valaxy:frontmatter",r),globalThis.$frontmatter=r,i({frontmatter:{title:"分布式",date:"2025-04-19",updated:"2025-04-19",categories:"java",tags:["java","笔记"],top:1}}),(n,m)=>{const h=c;return v(),g(h,{frontmatter:P(r)},{"main-content-md":l(()=>m[0]||(m[0]=[a("h1",{id:"分布式",tabindex:"-1"},[e("分布式 "),a("a",{class:"header-anchor",href:"#分布式","aria-label":'Permalink to "分布式"'},"​")],-1),a("h3",{id:"_1、分布式锁",tabindex:"-1"},[e("1、分布式锁 "),a("a",{class:"header-anchor",href:"#_1、分布式锁","aria-label":'Permalink to "1、分布式锁"'},"​")],-1),a("h4",{id:"使用原因",tabindex:"-1"},[e("使用原因 "),a("a",{class:"header-anchor",href:"#使用原因","aria-label":'Permalink to "使用原因"'},"​")],-1),a("p",null,"保证同一时间只有一个JVM进程可以对共享资源进行操作",-1),a("p",null,"实现方式 mysql、redis、redission、zk",-1),a("h4",{id:"mysql",tabindex:"-1"},[e("mysql "),a("a",{class:"header-anchor",href:"#mysql","aria-label":'Permalink to "mysql"'},"​")],-1),a("p",null,"依赖数据库的唯一性来实现资源锁定，比如主键、唯一索引等",-1),a("h4",{id:"redis",tabindex:"-1"},[e("redis "),a("a",{class:"header-anchor",href:"#redis","aria-label":'Permalink to "redis"'},"​")],-1),a("p",null,"用setnx操作 key存在 返回0，否则返回1",-1),a("p",null,"优点：实现简单、性能好，可以支撑高并发的获取、释放锁操作",-1),a("p",null,"缺点：容易单点故障",-1),a("h4",{id:"redission客户端",tabindex:"-1"},[e("redission客户端 "),a("a",{class:"header-anchor",href:"#redission客户端","aria-label":'Permalink to "redission客户端"'},"​")],-1),a("p",null,"调用lock和unlock方法",-1),a("p",null,"watchdog会在获取锁之后，每隔10s设置超时时间为30s，就算一直持有锁也不会出现key过期",-1),a("h4",{id:"zk",tabindex:"-1"},[e("zk "),a("a",{class:"header-anchor",href:"#zk","aria-label":'Permalink to "zk"'},"​")],-1),a("p",null,"在/lock目录下创建一个临时有序的节点表示去抢占锁，所有创建的节点会按照先后顺序生成一个带有序编号的节点",-1),a("p",null,"线程创建节点后，获取/lock节点下的所有子节点，判断当前线程创建的节点是否是所有的节点的序号最小的",-1),a("p",null,"如果当前线程创建的节点是所有节点序号最小的节点，则认为获取锁成功",-1),a("p",null,"如果当前线程创建的节点不是所有节点序号最小的节点，则对节点序号的前一个节点添加一个事件监听，当前一个被监听的节点释放锁之后，触发回调通知，从而再次去尝试抢占锁",-1),a("p",null,"优点：",-1),a("p",null,"zookeeper分布式协调、强一致性、锁很健壮。如果获取不到，只需要添加一个监听器就可以了，不用一直轮询，性能消耗较小",-1),a("p",null,"缺点：",-1),a("p",null,"在高请求高并发下，系统疯狂加锁释放锁，最后zk承受不住压力导致宕机",-1),a("h3",{id:"_2、分布式事务",tabindex:"-1"},[e("2、分布式事务 "),a("a",{class:"header-anchor",href:"#_2、分布式事务","aria-label":'Permalink to "2、分布式事务"'},"​")],-1),a("h4",{id:"理解",tabindex:"-1"},[e("理解 "),a("a",{class:"header-anchor",href:"#理解","aria-label":'Permalink to "理解"'},"​")],-1),a("p",null,"一个事务跨越多个分布式系统，可能由不同组织或部门进行管理，之间需要协调完成一个复杂的业务操作",-1),a("p",null,"需要满足ACID原则",-1),a("p",null,"要去解决事务操作的数据一致性问题。",-1),a("p",null,"传统的关系型数据库不支持跨库的事务操作，使用主流的分布式框架，像seata，集成到spring生态中",-1),a("h4",{id:"和spring事务区分",tabindex:"-1"},[e("和Spring事务区分 "),a("a",{class:"header-anchor",href:"#和spring事务区分","aria-label":'Permalink to "和Spring事务区分"'},"​")],-1),a("p",null,"spring没有提供事务，只是提供对事务的管理和封装，本质上是数据库层面的事务，需要满足ACID特性",-1),a("h3",{id:"_3、cap理论和base理论",tabindex:"-1"},[e("3、CAP理论和BASE理论 "),a("a",{class:"header-anchor",href:"#_3、cap理论和base理论","aria-label":'Permalink to "3、CAP理论和BASE理论"'},"​")],-1),a("h4",{id:"cap理论",tabindex:"-1"},[e("CAP理论 "),a("a",{class:"header-anchor",href:"#cap理论","aria-label":'Permalink to "CAP理论"'},"​")],-1),a("p",null,"在分布式系统中，必须保证分区容错性，无法同时保证强一致性和可用性",-1),a("p",null,"C：强一致性：各个节点之间能及时同步数据",-1),a("p",null,"A：可用性：对外保证可用",-1),a("p",null,"P：分区容错性：遇到任何网络故障时，仍然能对外提供满足一致性和可用性到服务",-1),a("p",null,"只能从一致性和可用性之间进行取舍。",-1),a("p",null,"如果保证了一致性，那么传输数据的时候，向客户端提交的请求就会失败或者超时。",-1),a("p",null,"如果保证了可用性，那就不能暂停读写操作，但同时在写数据",-1),a("h4",{id:"base理论",tabindex:"-1"},[e("BASE理论 "),a("a",{class:"header-anchor",href:"#base理论","aria-label":'Permalink to "BASE理论"'},"​")],-1),a("p",null,"BA：基本可用。出现故障的时候，运行损失部分可用性，但不等于系统不可用",-1),a("p",null,"S：中间状态：数据正在同步。允许数据存在中间状态，并认为该中间状态的存在不会影响系统的整体可用性",-1),a("p",null,"E：最终一致性：不要求数据实时达到一致，允许经过一段时间后再达到一致",-1),a("h3",{id:"_4、如何设计一个分布式系统",tabindex:"-1"},[e("4、如何设计一个分布式系统 "),a("a",{class:"header-anchor",href:"#_4、如何设计一个分布式系统","aria-label":'Permalink to "4、如何设计一个分布式系统"'},"​")],-1),a("p",null,"1、数据一致性：不同节点的数据不一定一致，需要采用一致性协议来保证数据的一致性",-1),a("p",null,"2、负载均衡：为了提高系统的可靠性，需要将请求均匀地分配给不同的节点，采用负载均衡算法实现：轮询、随机、加权随机、加权轮询",-1),a("p",null,"3、分布式事务：多个节点之间可能需要协作完成一个事务，需要采用分布式事务保证事务的原子性、一致性、隔离性和持久性，TCC",-1),a("p",null,"4、消息队列：实现异步通信和解耦，采用kafka、rabbitMQ等技术",-1),a("h3",{id:"_5、seata架构",tabindex:"-1"},[e("5、seata架构 "),a("a",{class:"header-anchor",href:"#_5、seata架构","aria-label":'Permalink to "5、seata架构"'},"​")],-1),a("p",null,"TC：事务协调者 维护全局和分支事务的状态，协调全局事务提交",-1),a("p",null,"TM：事务管理器 定义全局事务的范围，开始全局事务、提交或回滚全局事务",-1),a("p",null,"RM：资源管理器 管理分支事务处理的资源",-1),a("h3",{id:"_6、分布式事务解决方案",tabindex:"-1"},[e("6、分布式事务解决方案 "),a("a",{class:"header-anchor",href:"#_6、分布式事务解决方案","aria-label":'Permalink to "6、分布式事务解决方案"'},"​")],-1),a("p",null,"主要使用seata的at模式解决",-1),a("p",null,"分为两个阶段：",-1),a("p",null,"1、阶段一RM：注册分支事务、记录undolog快照、执行业务sql并提交、报告事务状态",-1),a("p",null,"2、阶段二提交RM：删除undolog",-1),a("p",null,"3、阶段二回滚RM：根据undo-log恢复数据到更新前",-1)])),"main-header":l(()=>[t(n.$slots,"main-header")]),"main-header-after":l(()=>[t(n.$slots,"main-header-after")]),"main-nav":l(()=>[t(n.$slots,"main-nav")]),"main-content-before":l(()=>[t(n.$slots,"main-content-before")]),"main-content":l(()=>[t(n.$slots,"main-content")]),"main-content-after":l(()=>[t(n.$slots,"main-content-after")]),"main-nav-before":l(()=>[t(n.$slots,"main-nav-before")]),"main-nav-after":l(()=>[t(n.$slots,"main-nav-after")]),comment:l(()=>[t(n.$slots,"comment")]),footer:l(()=>[t(n.$slots,"footer")]),aside:l(()=>[t(n.$slots,"aside")]),"aside-custom":l(()=>[t(n.$slots,"aside-custom")]),default:l(()=>[t(n.$slots,"default")]),_:3},8,["frontmatter"])}}};export{w as default,$ as usePageData};
