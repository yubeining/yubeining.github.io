import{_ as f}from"./ValaxyMain.vue_vue_type_style_index_0_lang.DXFDIcRI.js";import{f as p,a as b,u as k}from"./chunks/vue-router.CE6eJGTm.js";import{O as q,a4 as e,V as l,U as a,X as t,u as v,P as _,A as M}from"./framework.CgPPQfmH.js";import"./app.2Hk-Pb-P.js";import"./chunks/dayjs.CCYrSalk.js";import"./chunks/vue-i18n.BoM8szIi.js";import"./chunks/pinia.BjFmakTL.js";import"./chunks/@vueuse/motion.Cp--YhDB.js";import"./chunks/nprogress.BahbDzmd.js";import"./YunComment.vue_vue_type_style_index_0_lang.DC8N30BB.js";import"./index.C5okkQwF.js";import"./YunPageHeader.vue_vue_type_script_setup_true_lang.PEAAi8W5.js";import"./post.CGlAV6UI.js";const Q=p("/posts/study notes/java base knowledge/mq",async o=>JSON.parse('{"title":"mq","description":"","frontmatter":{"title":"mq","date":"2025-04-19","updated":"2025-04-19","categories":"java","tags":["java","笔记"],"top":1},"headers":[{"level":3,"title":"1、使用MQ场景","slug":"_1、使用mq场景","link":"#_1、使用mq场景","children":[]},{"level":3,"title":"2、介绍MQ","slug":"_2、介绍mq","link":"#_2、介绍mq","children":[]},{"level":3,"title":"3、负载均衡","slug":"_3、负载均衡","link":"#_3、负载均衡","children":[]},{"level":3,"title":"4、保证MQ消息不丢失","slug":"_4、保证mq消息不丢失","link":"#_4、保证mq消息不丢失","children":[]},{"level":3,"title":"5、保证MQ接受消息顺序性","slug":"_5、保证mq接受消息顺序性","link":"#_5、保证mq接受消息顺序性","children":[]},{"level":3,"title":"6、重复消费问题","slug":"_6、重复消费问题","link":"#_6、重复消费问题","children":[]}],"relativePath":"pages/posts/study notes/java base knowledge/mq.md","lastUpdated":1745542762000}'),{lazy:(o,i)=>o.name===i.name}),T={__name:"mq",setup(o,{expose:i}){var d;const{data:s}=Q(),c=k(),m=b(),n=Object.assign(m.meta.frontmatter||{},((d=s.value)==null?void 0:d.frontmatter)||{});return m.meta.frontmatter=n,c.currentRoute.value.data=s.value,M("valaxy:frontmatter",n),globalThis.$frontmatter=n,i({frontmatter:{title:"mq",date:"2025-04-19",updated:"2025-04-19",categories:"java",tags:["java","笔记"],top:1}}),(r,h)=>{const u=f;return _(),q(u,{frontmatter:v(n)},{"main-content-md":e(()=>h[0]||(h[0]=[a("h1",{id:"mq",tabindex:"-1"},[t("MQ "),a("a",{class:"header-anchor",href:"#mq","aria-label":'Permalink to "MQ"'},"​")],-1),a("h3",{id:"_1、使用mq场景",tabindex:"-1"},[t("1、使用MQ场景 "),a("a",{class:"header-anchor",href:"#_1、使用mq场景","aria-label":'Permalink to "1、使用MQ场景"'},"​")],-1),a("h4",{id:"异步任务处理",tabindex:"-1"},[t("异步任务处理 "),a("a",{class:"header-anchor",href:"#异步任务处理","aria-label":'Permalink to "异步任务处理"'},"​")],-1),a("p",null,"当项目需要处理一些耗时的任务。通过将任务放入消息队列中，让应用程序快速响应请求，并将任务交给后台的工作线程来处理",-1),a("h4",{id:"解耦系统组件",tabindex:"-1"},[t("解耦系统组件 "),a("a",{class:"header-anchor",href:"#解耦系统组件","aria-label":'Permalink to "解耦系统组件"'},"​")],-1),a("p",null,"当系统中不同组件需要进行通信时，使用MQ实现解耦。每个组件可以通过消息队列发送和接收消息，而不需要直接依赖其他组件。",-1),a("h4",{id:"数据传输",tabindex:"-1"},[t("数据传输 "),a("a",{class:"header-anchor",href:"#数据传输","aria-label":'Permalink to "数据传输"'},"​")],-1),a("p",null,"当需要将数据从一个应用程序传输到另一个应用程序，使用MQ，从而避免直接依赖网络和数据传输的稳定性",-1),a("h4",{id:"消息通知",tabindex:"-1"},[t("消息通知 "),a("a",{class:"header-anchor",href:"#消息通知","aria-label":'Permalink to "消息通知"'},"​")],-1),a("p",null,"当需要通知多个应用程序或者用户，可以使用MQ来发送通知消息，从而实现消息的广播和通知功能",-1),a("h3",{id:"_2、介绍mq",tabindex:"-1"},[t("2、介绍MQ "),a("a",{class:"header-anchor",href:"#_2、介绍mq","aria-label":'Permalink to "2、介绍MQ"'},"​")],-1),a("h4",{id:"缺点",tabindex:"-1"},[t("缺点 "),a("a",{class:"header-anchor",href:"#缺点","aria-label":'Permalink to "缺点"'},"​")],-1),a("p",null,"降低系统的可用性：系统引入的外部依赖越多，越容易挂掉",-1),a("p",null,"系统复杂度提高：使用MQ后可能需要保障消息没有被重复消费、处理消息丢失的情况、保证消息传递的顺序性等问题",-1),a("p",null,"一致性问题：写库操作失败导致数据不一致",-1),a("h3",{id:"_3、负载均衡",tabindex:"-1"},[t("3、负载均衡 "),a("a",{class:"header-anchor",href:"#_3、负载均衡","aria-label":'Permalink to "3、负载均衡"'},"​")],-1),a("h4",{id:"生产者端负载均衡",tabindex:"-1"},[t("生产者端负载均衡 "),a("a",{class:"header-anchor",href:"#生产者端负载均衡","aria-label":'Permalink to "生产者端负载均衡"'},"​")],-1),a("p",null,"生产者将消息发送到多个队列中，这些队列可以在多个MQ节点进行分布，通过在发送消息时随机选择或轮询选择不同的队列",-1),a("h4",{id:"消费者端负载均衡",tabindex:"-1"},[t("消费者端负载均衡 "),a("a",{class:"header-anchor",href:"#消费者端负载均衡","aria-label":'Permalink to "消费者端负载均衡"'},"​")],-1),a("p",null,"MQ 提供了多个消费者订阅同一个队列的功能。当有消息到达队列时，MQ 将消息分发给其中一个消费者进行处理。通过增加多个消费者来订阅队列，可以实现消费者端的负载均衡。",-1),a("h3",{id:"_4、保证mq消息不丢失",tabindex:"-1"},[t("4、保证MQ消息不丢失 "),a("a",{class:"header-anchor",href:"#_4、保证mq消息不丢失","aria-label":'Permalink to "4、保证MQ消息不丢失"'},"​")],-1),a("p",null,"生产者弄丢了消息：开启confirm模式",-1),a("p",null,"mq弄丢消息：开启broker持久化",-1),a("p",null,"消费者弄丢消息：关闭自动ack，手动ack",-1),a("h3",{id:"_5、保证mq接受消息顺序性",tabindex:"-1"},[t("5、保证MQ接受消息顺序性 "),a("a",{class:"header-anchor",href:"#_5、保证mq接受消息顺序性","aria-label":'Permalink to "5、保证MQ接受消息顺序性"'},"​")],-1),a("p",null,"分区排序：将消息按照某个分区规则进行分区，每个分区由一个独立的消费者来处理",-1),a("p",null,"全局排序：如果业务对于消息的严格顺序要求非常高，可以考虑使用全局排序的机制，确保消息在整个MQ集群中按照顺序处理。",-1),a("p",null,"同一个订单号的消息发送到同一个queue中，同一个队列的消息一定会保证有序",-1),a("h3",{id:"_6、重复消费问题",tabindex:"-1"},[t("6、重复消费问题 "),a("a",{class:"header-anchor",href:"#_6、重复消费问题","aria-label":'Permalink to "6、重复消费问题"'},"​")],-1),a("p",null,"每条消息设置一个唯一的标识id",-1),a("p",null,"幂等方案：分布式锁、数据库锁",-1)])),"main-header":e(()=>[l(r.$slots,"main-header")]),"main-header-after":e(()=>[l(r.$slots,"main-header-after")]),"main-nav":e(()=>[l(r.$slots,"main-nav")]),"main-content-before":e(()=>[l(r.$slots,"main-content-before")]),"main-content":e(()=>[l(r.$slots,"main-content")]),"main-content-after":e(()=>[l(r.$slots,"main-content-after")]),"main-nav-before":e(()=>[l(r.$slots,"main-nav-before")]),"main-nav-after":e(()=>[l(r.$slots,"main-nav-after")]),comment:e(()=>[l(r.$slots,"comment")]),footer:e(()=>[l(r.$slots,"footer")]),aside:e(()=>[l(r.$slots,"aside")]),"aside-custom":e(()=>[l(r.$slots,"aside-custom")]),default:e(()=>[l(r.$slots,"default")]),_:3},8,["frontmatter"])}}};export{T as default,Q as usePageData};
