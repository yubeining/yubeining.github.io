import{_ as h}from"./ValaxyMain.vue_vue_type_style_index_0_lang.DXFDIcRI.js";import{f,a as v,u as b}from"./chunks/vue-router.CE6eJGTm.js";import{O as k,a4 as a,V as n,U as l,X as e,u as g,P,A as y}from"./framework.CgPPQfmH.js";import"./app.2Hk-Pb-P.js";import"./chunks/dayjs.CCYrSalk.js";import"./chunks/vue-i18n.BoM8szIi.js";import"./chunks/pinia.BjFmakTL.js";import"./chunks/@vueuse/motion.Cp--YhDB.js";import"./chunks/nprogress.BahbDzmd.js";import"./YunComment.vue_vue_type_style_index_0_lang.DC8N30BB.js";import"./index.C5okkQwF.js";import"./YunPageHeader.vue_vue_type_script_setup_true_lang.PEAAi8W5.js";import"./post.CGlAV6UI.js";const $=f("/posts/study notes/java base knowledge/rpc",async o=>JSON.parse('{"title":"rpc","description":"","frontmatter":{"title":"rpc","date":"2025-04-19","updated":"2025-04-19","categories":"java","tags":["java","笔记"],"top":1},"headers":[{"level":2,"title":"目标是实现方法的远程调用","slug":"目标是实现方法的远程调用","link":"#目标是实现方法的远程调用","children":[]},{"level":2,"title":"rpc","slug":"rpc","link":"#rpc","children":[]},{"level":2,"title":"注册中心","slug":"注册中心","link":"#注册中心","children":[]},{"level":2,"title":"动态代理实现","slug":"动态代理实现-1","link":"#动态代理实现-1","children":[]},{"level":2,"title":"服务注册和服务发现实现","slug":"服务注册和服务发现实现","link":"#服务注册和服务发现实现","children":[]},{"level":2,"title":"负载均衡","slug":"负载均衡-1","link":"#负载均衡-1","children":[]},{"level":2,"title":"本地缓存","slug":"本地缓存","link":"#本地缓存","children":[]},{"level":2,"title":"服务容错和服务重试","slug":"服务容错和服务重试","link":"#服务容错和服务重试","children":[{"level":3,"title":"问题：","slug":"问题","link":"#问题","children":[]}]}],"relativePath":"pages/posts/study notes/java base knowledge/rpc.md","lastUpdated":1745542762000}'),{lazy:(o,i)=>o.name===i.name}),A={__name:"rpc",setup(o,{expose:i}){var u;const{data:s}=$(),d=b(),p=v(),t=Object.assign(p.meta.frontmatter||{},((u=s.value)==null?void 0:u.frontmatter)||{});return p.meta.frontmatter=t,d.currentRoute.value.data=s.value,y("valaxy:frontmatter",t),globalThis.$frontmatter=t,i({frontmatter:{title:"rpc",date:"2025-04-19",updated:"2025-04-19",categories:"java",tags:["java","笔记"],top:1}}),(r,c)=>{const m=h;return P(),k(m,{frontmatter:g(t)},{"main-content-md":a(()=>c[0]||(c[0]=[l("h1",{id:"rpc框架项目",tabindex:"-1"},[e("RPC框架项目 "),l("a",{class:"header-anchor",href:"#rpc框架项目","aria-label":'Permalink to "RPC框架项目"'},"​")],-1),l("h2",{id:"目标是实现方法的远程调用",tabindex:"-1"},[e("目标是实现方法的远程调用 "),l("a",{class:"header-anchor",href:"#目标是实现方法的远程调用","aria-label":'Permalink to "目标是实现方法的远程调用"'},"​")],-1),l("h2",{id:"rpc",tabindex:"-1"},[e("rpc "),l("a",{class:"header-anchor",href:"#rpc","aria-label":'Permalink to "rpc"'},"​")],-1),l("p",null,"rpc三个核心consumer、provider、register",-1),l("p",null,"consumer经过注册中心调用provider中的方法",-1),l("p",null,"传统的方式是consumer调用httpclient请求，配置繁琐，而且配置写死不好改动",-1),l("p",null,"还需要自己序列化和反序列化的操作",-1),l("p",null,"使用rpc 只需要使用代理对象 引入服务调用就行",-1),l("p",null,"下载代码到本地添加依赖到项目中就可以使用",-1),l("p",null,"作为rpc框架，需要配置使用哪个服务器接收请求，比如说tomcat、netty、jetty",-1),l("p",null,"通过tomcat接收到请求，交给dispacherselvert执行：",-1),l("p",null,"（将consumer需要的方法内容传递给provider）",-1),l("p",null,"需要处理什么样的请求，需要接收：",-1),l("p",null,"接口名、方法的名字、方法的参数类型列表、方法的参数值列表",-1),l("p",null,"通过getinputstream反序列化创建invocation对象",-1),l("p",null,"反序列化默认采用jdk序列化方法",-1),l("p",null,"根据创建的对象从注册中心中找到对应的接口（使用接口不用具体的实现类，用接口依赖的比较少）",-1),l("p",null,"根据反射来完成对象方法的实现，通过序列化的方式返回给consumer",-1),l("p",null,"基础的rpc框架实现了，下面进行优化：",-1),l("h6",{id:"注册中心提供远程注册服务",tabindex:"-1"},[e("注册中心提供远程注册服务 "),l("a",{class:"header-anchor",href:"#注册中心提供远程注册服务","aria-label":'Permalink to "注册中心提供远程注册服务"'},"​")],-1),l("p",null,"（consumer拿到调用方法的ip+port）",-1),l("p",null,"下一次调用的时候直接从redis中取即可",-1),l("h6",{id:"动态代理实现",tabindex:"-1"},[e("动态代理实现 "),l("a",{class:"header-anchor",href:"#动态代理实现","aria-label":'Permalink to "动态代理实现"'},"​")],-1),l("p",null,"consumer不可能新建httpservlet服务繁琐配置",-1),l("p",null,"直接新建proxyfactory进行服务配置 建立连接",-1),l("p",null,"根据proxyfactory拿到序列化的实现",-1),l("p",null,"那些配置信息都写在代理对象中",-1),l("p",null,"然后返回结果",-1),l("h6",{id:"服务注册和服务发现",tabindex:"-1"},[e("服务注册和服务发现 "),l("a",{class:"header-anchor",href:"#服务注册和服务发现","aria-label":'Permalink to "服务注册和服务发现"'},"​")],-1),l("p",null,"consumer得到调用服务的url 存到consumer的地方",-1),l("p",null,"将url保存到redis中，下次调用的时候直接从redis中取即可",-1),l("h6",{id:"负载均衡",tabindex:"-1"},[e("负载均衡 "),l("a",{class:"header-anchor",href:"#负载均衡","aria-label":'Permalink to "负载均衡"'},"​")],-1),l("p",null,"需要连接哪个tomcat，从哪个tomcat上得到请求",-1),l("p",null,"使用随机算法对urls列表进行选取，拿取url",-1),l("p",null,"都是客户端负载均衡",-1),l("h6",{id:"服务容错和服务尝试",tabindex:"-1"},[e("服务容错和服务尝试 "),l("a",{class:"header-anchor",href:"#服务容错和服务尝试","aria-label":'Permalink to "服务容错和服务尝试"'},"​")],-1),l("p",null,"处理异常、",-1),l("p",null,"调用失败再次尝试调用",-1),l("h2",{id:"注册中心",tabindex:"-1"},[e("注册中心 "),l("a",{class:"header-anchor",href:"#注册中心","aria-label":'Permalink to "注册中心"'},"​")],-1),l("p",null,"本地注册",-1),l("p",null,"使用hashmap存储请求 string class",-1),l("p",null,"register方法 将获得的请求以及实现内容存入hashmap中",-1),l("p",null,"get方法，拿到注册中心的请求",-1),l("p",null,"是在provider中首先注册的请求",-1),l("p",null,"redis作为注册中心，当provider新增节点或者改变的时候，",-1),l("p",null,"注册中心以及consumer本地缓存需要同步",-1),l("p",null,"redis消费订阅机制",-1),l("p",null,"如何发现provider节点挂了？",-1),l("p",null,"redis里的watch机制",-1),l("h2",{id:"动态代理实现-1",tabindex:"-1"},[e("动态代理实现 "),l("a",{class:"header-anchor",href:"#动态代理实现-1","aria-label":'Permalink to "动态代理实现"'},"​")],-1),l("p",null,"consumer方法太复杂",-1),l("p",null,"需要得到方法的代理对象",-1),l("p",null,"Rpcframework 新建proxyfactory",-1),l("p",null,"调用方法时直接调用代理对象",-1),l("p",null,"使用invoke方法 将原本的逻辑放到invoke方法中",-1),l("p",null,"proxyfactory处理httpclient、服务发现、负载均衡",-1),l("h2",{id:"服务注册和服务发现实现",tabindex:"-1"},[e("服务注册和服务发现实现 "),l("a",{class:"header-anchor",href:"#服务注册和服务发现实现","aria-label":'Permalink to "服务注册和服务发现实现"'},"​")],-1),l("p",null,"服务提供者在启动的时候能够将服务存到注册中心上",-1),l("p",null,"消费者能从注册中心获得ip+port",-1),l("p",null,"编写一个url",-1),l("p",null,"实现远程注册类",-1),l("p",null,"将url存入map中",-1),l("p",null,"服务注册：",-1),l("p",null,"需要存放url",-1),l("p",null,"服务发现：",-1),l("p",null,"需要得到存放的url",-1),l("h2",{id:"负载均衡-1",tabindex:"-1"},[e("负载均衡 "),l("a",{class:"header-anchor",href:"#负载均衡-1","aria-label":'Permalink to "负载均衡"'},"​")],-1),l("p",null,"从redis中得到url之后",-1),l("p",null,"应该发送给哪一个tomcat",-1),l("p",null,"将服务发现得到的urls列表进行随机算法的负载均衡",-1),l("p",null,"最小活跃数：选择一个负载最小的服务器",-1),l("h2",{id:"本地缓存",tabindex:"-1"},[e("本地缓存 "),l("a",{class:"header-anchor",href:"#本地缓存","aria-label":'Permalink to "本地缓存"'},"​")],-1),l("p",null,"消费者去查url的时候，不需要每次都从注册中心中查询，",-1),l("p",null,"采用本地缓存的方法实现",-1),l("p",null,"将查到的ip+port保存到redis中",-1),l("p",null,"问题：和注册中心数据保存一致",-1),l("p",null,"redis消费订阅机制",-1),l("h2",{id:"服务容错和服务重试",tabindex:"-1"},[e("服务容错和服务重试 "),l("a",{class:"header-anchor",href:"#服务容错和服务重试","aria-label":'Permalink to "服务容错和服务重试"'},"​")],-1),l("p",null,"服务容错：在服务调用的时候抛出异常，定义一个方法处理这个异常",-1),l("p",null,"高级容错–读取用户的配置 class+方法名 根据用户的配置信息处理容错",-1),l("p",null,"服务重试：调用服务失败的时候进行重试，重试次数不超过3次",-1),l("h3",{id:"问题",tabindex:"-1"},[e("问题： "),l("a",{class:"header-anchor",href:"#问题","aria-label":'Permalink to "问题："'},"​")],-1),l("p",null,"1、为什么不能直接调用实现类？",-1),l("p",null,"有很多依赖，但是接口依赖比较少",-1),l("p",null,"2、consumer如何才能远程调用？",-1),l("p",null,"首先需要进行网络传输，启动服务器，接受请求",-1),l("p",null,"需要配置服务器，选择tomcat、netty、jetty中的一个",-1),l("p",null,"3、如何设计rpc协议",-1),l("p",null,"可以自定义请求头和请求体",-1),l("p",null,"数据头：RPC version 消费名 请求体",-1),l("p",null,"数据体：Invocation",-1),l("p",null,"RPC协议–数据格式+传输方式",-1)])),"main-header":a(()=>[n(r.$slots,"main-header")]),"main-header-after":a(()=>[n(r.$slots,"main-header-after")]),"main-nav":a(()=>[n(r.$slots,"main-nav")]),"main-content-before":a(()=>[n(r.$slots,"main-content-before")]),"main-content":a(()=>[n(r.$slots,"main-content")]),"main-content-after":a(()=>[n(r.$slots,"main-content-after")]),"main-nav-before":a(()=>[n(r.$slots,"main-nav-before")]),"main-nav-after":a(()=>[n(r.$slots,"main-nav-after")]),comment:a(()=>[n(r.$slots,"comment")]),footer:a(()=>[n(r.$slots,"footer")]),aside:a(()=>[n(r.$slots,"aside")]),"aside-custom":a(()=>[n(r.$slots,"aside-custom")]),default:a(()=>[n(r.$slots,"default")]),_:3},8,["frontmatter"])}}};export{A as default,$ as usePageData};
