---
title: java jvm
date: 2025-04-19
updated: 2025-04-19
categories: java
tags:
  - java
  - 笔记
top: 1
---

# JVM

### 1、jvm内存区域分布

#### 程序计数器

保存着当前线程所执行的字节码指令的地址。每个线程都有一个独立的程序计数器，用于控制线程的执行流程。

因为JVM的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器都只会执行一条线程中的命令。为了线程切换之后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器。

#### java栈

每个方法在执行的时候都会创建一个帧栈，存储方法的局部变量、方法参数、返回值和操作数栈

为虚拟机执行java方法服务

#### 本地方法栈

与java栈类似，但用于执行本地方法的数据和信息

为虚拟机使用到的native方法服务

#### 堆

最大的一块内存区域，用于存储对象实例和数组。所有的对象实例和数组都在堆上分配内存空间。

堆被所有线程共享，在java虚拟机启动时被创建

是垃圾收集器管理的主要区域，也被称为GC堆

#### 方法区

各个线程共享的内存区域

用于存储已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。jdk8后，永久代被元空间取代


#### 运行时常量池

方法区等一部分，用于存放编译器生成的各种字面量和符号引用。包含了类和接口的常量、字段和方法的符号引用

常量池：可以看作一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等信息

当类被加载，它的常量池信息就会放入运行时常量池，并把里面符号地址变为真实地址






#### 堆内存的分区

分为两个不同的区域：新生代和老年代

新生代分为一个较小的eden空间和两个较小的survivor空间

老年代则大很多



#### 为什么JVM使用了元空间替换了永久代
metaspace是存储类信息、常量池等数据结构等区域
1.7中的永久代是有上限的，jvm加载的class总数是很难确定的，容易出现oom的问题

元空间是存储在本地内存中，内存上限很大

替换后，简化了fullgc垃圾回收的过程，提升了gc的性能





### 2、垃圾回收算法

#### 标记清除算法

最基本的垃圾回收算法。从根结点开始，标记所有被引用的对象。在清除阶段，遍历整个堆，清除所有未被标记的对象。缺点是会产生内存碎片

#### 标记复制算法

将堆内存分为两块区域。当一块区域被填满之后，将存活的对象复制到另一块区域中，然后清除原来的区域。不会产生内存碎片，但是需要额外的空间

#### 标记整理算法

标记所有被引用的对象，然后将存活的对象向一端移动，并清除边界之外的内存。

#### 分代算法

将堆内存划分为几个代，通常是新生代和老年代。在堆区之外还有一个代是永久代

新生代每次垃圾回收时都有大量的对象需要被回收，那么就可以根据不同代的特点采取最适合的收集算法



#### 分代收集下的年轻代和⽼年代应该采⽤什么样的垃圾回收算法

年轻代：标记复制算法

大多数生命周期较短，很快被回收

老年代：标记-清除-整理算法





#### 内存碎片以及解决方式

垃圾回收后，不进行整理，就会出现内存碎片。会导致无法分配大块的内存空间



### 3、对象可以被回收的条件

是否可以被回收是由垃圾回收器来决定的

#### 引用可达性

当一个对象不再被任何活动线程所引用时，被认为是不可达的



#### finalize方法状态

如果一个对象的finalize()方法被调用并且执行完成，那么该对象是可以被回收的



#### 被标记为垃圾的对象一定会被回收吗

第一次标记：在可达性分析后发现没有与GC Roots相连接的引用链，会被第一次标记。

第二次标记：是否有必要执行finalize() ⽅法，如果没有与新的引用链建立关联关系，则会被进行第二次标记。如果与引用链建立了关联关系，那么将会逃离本次回收，继续存活。



### 4、GC ROOT对象

GC ROOT对象是指那些被认为是存活对象的根结点。垃圾回收器通过从这些根结点出发，遍历对象引用链，判断哪些对象是可达的，哪些是不可达的



常见的GC ROOT对象：

方法区中的类静态属性：存储在方法区中，随着类的加载而被创建，并且在整个程序的生命周期内存在

方法区中的常量引用：常量池中存储着常量的引用，包括字符串常量、类名、方法名等

活动线程的本地变量和调用栈

JNI引用



### 5、JVM调优

#### 性能测试和压测

模拟真实场景下的负载情况，发现潜在的性能问题和瓶颈

#### 代码优化

优化代码逻辑和算法，减少资源消耗和性能瓶颈。避免频繁的对象创建和销毁，合理使用缓存和数据结构，减少不必要的IO操作

#### 线程调优

合理管理线程资源，避免线程过多或线程阻塞导致的性能问题

#### 内存调优

合理设置堆内存大小、新生代和老年代的比例，选择适当的垃圾回收器和相关参数配置，可以有效提升应用的性能和稳定性

#### 垃圾回收调优

选择合适的垃圾回收算法



### 6、排查CPU飙升的问题

#### 可能原因

1、CPU上下文切换过多

线程过多，CPU通过上下文切换来执行不同的线程，大量占用CPU资源

文件IO、网络IO导致线程阻塞

2、CPU资源过度消耗

有线程占据CPU资源，无法被释放



可以通过top命令，再通过shift+H找到进程中CPU消耗过高的线程

也可能是用户访问量突然增大导致的，可以增加系统资源



#### 排查问题（JVM）

1、正常运行的系统

jmap 查看各个区域内存使用情况
jstack 线程运行情况
jstat 垃圾回收情况  fullgc 比较频繁就需要调优 是否回收了很多对象 

最好在younggc直接回收
找到占用cpu最多的线程 top命令 shift+H找到CPU消耗过高的线程
​	

2、已经发生OOM的系统

查看发生OOM时，生成当时的dump文件

找到异常的实例对象、异常的线程，进行详细的分析和调试



### 7、内存泄漏

#### 内存泄漏对象的特点

可达的、无用的，这些对象就可以判定为java中的内存泄漏，这些对象不会被gc回收，但是占用内存



#### 情况





#### 避免内存泄露的方法

1、尽量不要使用static成员变量，减少生命周期

2、及时关闭资源

3、不用的对象，可以手动设置为null



### 8、方法执行过程

方法没有被调用时，在方法区中的字节码文件存放

方法被调用时，需要进入到栈内存中运行

方法区：字节码文件加载时进入到内存 源文件有什么、字节码就有什么

栈内存：方法运行的时候进入的内存





#### debug执行过程

源文件编译成字节码文件，进入方法区，当方法被虚拟机调用执行，进入栈内存



### 9、JVM主要组成部分及其作用

1、类加载器

2、运行时数据区

3、执行引擎

4、本地库接口

⾸先通过类加载器（ClassLoader）会把 Java 代码转换成字节码，运⾏时数据区（Runtime Data Area）再把字节码加载到内存中，⽽字节码⽂件只是 JVM 的⼀套指令集规范，并不能直接交给底层操作系统去执⾏，因此需要特定的命令解析器执⾏引擎（Execution Engine），将字节码翻译成底层系统指令，再交由 CPU 去执⾏，⽽这个过程中需要调⽤其他语⾔的本地库接⼝（Native Interface）来实现整个程序的功能。



### 10、类加载机制

#### 类加载器及作用

BootstrapClassLoader 是ExtClassLoader的父加载器

ExtClassLoader 是AppClassLoader的父加载器

AppClassLoader



#### 双亲委派机制、类加载过程

JVM加载类的时候，会委派给Ext和Bootstrarp进行加载，没加载到才由自己加载

调用AppclassLoader的loadClass方法加载这个类，先调用ExtClassLoader的loadClass方法加载类，先调用BootstrapClassLoader的loadClass方法加载类，没加载到的话，ExtClassLoader先自己尝试加载，然后AppClassLoader自己加载

为什么要采用双亲委派机制？
可以避免某一个类被重复加载，当父类已经加载后则无需重复加载，保证唯一性
为了安全，保证类库API不会被修改




### 11、指令重排

在编译java代码时，为了优化执行效率，可能会改变指令的执行顺序，导致程序执行的结果与预期不一致。

解决指令重排的方法：

1、volatile关键字：保证线程对当前变量的操作是有序的

2、synchronized关键字：保证线程之间的可见性和互斥性，确保执行顺序的一致性。可以防止多线程访问同一段代码的并行执行，从而避免了由指令重排引起的问题

3、线程局部变量：它不会被多个线程共享，也就不会存在指令重排的问题 threadlocal



### 12、G1收集器

#### 垃圾回收的瓶颈：

传统垃圾算法无法解决Full GC所带来的应用暂停，在一些对实时性要求高的应用场景，GC暂停带来的请求堆积和失败是无法接受的。

G1不同于传统的垃圾回收器，将整个堆内存作为一个整体，将堆内存分成多个大小相等的区域。根据堆内存的使用情况，动态选择一些包含垃圾对象比较多的区域进行回收。



### 13、fullgc原理

停止应用程序，对jvm中所有的内存进行垃圾回收的过程

#### 触发条件

堆内存空间不足、显式调用、老年代空间不足、

#### 工作过程

标记阶段，从根对象出发，递归标记所有可达对象，并将它们标记为活动对象

确认标记的一致性。然后将所有未标记的对象清除，并回收内存空间

整理压缩，将存活的对象向一端移动



#### 频繁full gc如何处理

增加堆内存的大小：-Xms -Xmx

检查内存泄漏：使用内存分析工具进行分析

调整垃圾回收参数：调整年轻代和老年代的分配比例

