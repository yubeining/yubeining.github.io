---
title: mq
date: 2025-04-19
updated: 2025-04-19
categories: java
tags:
  - java
  - 笔记
top: 1
---

# MQ

### 1、使用MQ场景

#### 异步任务处理

当项目需要处理一些耗时的任务。通过将任务放入消息队列中，让应用程序快速响应请求，并将任务交给后台的工作线程来处理

#### 解耦系统组件

当系统中不同组件需要进行通信时，使用MQ实现解耦。每个组件可以通过消息队列发送和接收消息，而不需要直接依赖其他组件。

#### 数据传输

当需要将数据从一个应用程序传输到另一个应用程序，使用MQ，从而避免直接依赖网络和数据传输的稳定性

#### 消息通知

当需要通知多个应用程序或者用户，可以使用MQ来发送通知消息，从而实现消息的广播和通知功能





### 2、介绍MQ
消息队列是一种用于在多台机器上并发地传输和存储事件的技术。它可以提供可靠的消息传递机制，使得消息可以在多个线程、进程或服务器之间安全地交换

生产者->消息队列->消费者

以下是 KAFKA 执行过程的大致概述：

1、消息生成：消费者会持续接收来自生产者的消息，这些消息被标记为“生产者发送的”。
2、消息传递：消息会被分发到不同的队列中，并且每个队列都由一个单独的消费者处理。因此，可以将多个消费者的请求分配给同一个或多个队列。
3、消息消费：消费者会持续地从队列中获取并处理消息，直到队列为空。
4、消息发布与订阅：消息可以通过监听特定主题（topic）来发布和订阅。


#### 缺点

降低系统的可用性：系统引入的外部依赖越多，越容易挂掉

系统复杂度提高：使用MQ后可能需要保障消息没有被重复消费、处理消息丢失的情况、保证消息传递的顺序性等问题

一致性问题：写库操作失败导致数据不一致





### 3、负载均衡

#### 生产者端负载均衡

生产者将消息发送到多个队列中，这些队列可以在多个MQ节点进行分布，通过在发送消息时随机选择或轮询选择不同的队列

#### 消费者端负载均衡

MQ 提供了多个消费者订阅同一个队列的功能。当有消息到达队列时，MQ 将消息分发给其中一个消费者进行处理。通过增加多个消费者来订阅队列，可以实现消费者端的负载均衡。



### 4、保证MQ消息不丢失

生产者弄丢了消息：开启confirm模式

mq弄丢消息：开启broker持久化

消费者弄丢消息：关闭自动ack，手动ack


持久化存储: 在MQ中，消息可以保存在持久化的存储设备上，这样即使网络断开或系统重启，消息也会正确地保留下来。这通常需要额外的存储空间和配置，但是它可以防止丢失。

消息队列重试策略: 提供一个明确的消息重试机制，当处理失败时能够自动重发。



### 5、保证MQ接受消息顺序性

分区排序：将消息按照某个分区规则进行分区，每个分区由一个独立的消费者来处理

全局排序：如果业务对于消息的严格顺序要求非常高，可以考虑使用全局排序的机制，确保消息在整个MQ集群中按照顺序处理。



同一个订单号的消息发送到同一个queue中，同一个队列的消息一定会保证有序



### 6、重复消费问题

每条消息设置一个唯一的标识id

幂等方案：分布式锁、数据库锁


### 7、消息堆积问题
当生产者发送消息的速度超过消费者处理消息的速度 
当队列消息达到存储上限，之前的消息就会成为死信，可能会被丢弃

解决方案：
1、增加更多消费者，提高消费速度
2、在消费者内开启线程池加快消息处理速度
3、扩大队列容积，提高堆积上限，使用惰性队列
接受到消息后直接存入磁盘而非内存
消费者要消费消息时才会从磁盘中读取并加载到内存


### 8、消息模型有哪些 rabbitMq和RocketMq的区别
1、队列模型
rabbitMq采用队列模型
生产者将消息发送到队列中，多个消费者可以订阅同一条队列，但每条消息只能被其中一个消费者消费

2、发布/订阅模型
RocketMQ、Kafka
生产者将消息发布到主题（topic），多个消费者可以订阅该主题，所有订阅者都会收到消息


### 9、mq如何实现事务控制
1、开启事务
使用channel.txSelect()方法将当前信道（Channel）
设置为事务模式

2、执行消息操作
在事务中发送消息：开启事务后，所有通过该信道发送的消息都将处于事务控制之下

3、提交或回滚事务
提交事务：所有在事务中发送的消息将被确认并投递到队列

回滚事务：所有在事务中发送的消息将被丢弃，不会投递到队列


### 10、死信队列
用于存储无法被正常消费的消息。
当消息由于某些原因无法被消费者正确处理后，
这些消息将被转移到死信队列

成为死信的原因：
1、消息被拒绝且不重试
消费者在处理消息时发生错误，主动拒绝消息，表示不再将消息重新入队

2、消息过期
消息设置了存货时间，在指定时间内未被消费，消息变为死信

3、队列达到最大长度
队列设置了最大消息数量，当队列满时，新消息无法进入，可能被丢弃或成为死信

4、消费者处理失败
消费者在处理消息时出现异常或崩溃，导致消息未能成功确认


死信队列的作用：
1、防止消息丢失
将无法消费的消息保存到死信队列，避免直接丢弃
2、提高系统可靠性
隔离失败消息，防止其阻塞正常队列，确保系统稳定运行
3、便于问题排查和修复
集中存储失败消息，开发人员可以分析死信原因，确保系统稳定运行
4、实现延迟重试
将死信队列作为缓冲区，定时或手动将消息重新投递给消费者，尝试再次处理


