---
title: java基础
date: 2025-04-19
updated: 2025-04-19
categories: java
tags:
  - java
  - 笔记
top: 1
---
## 基础知识
### 1、面向对象、面向过程

#### 区别

面向过程：实现函数开发的

面向对象：一种编程指导思想，将具体的实物抽象为类并具有属性和方法，通过实例化完成功能

分别从业务、设计、开发角度进行理解

业务：对真实的业务概念抽象成对象，业务需求变化可以通过增加、修改或替换对象来实现

设计：模块化和封装、将系统划分为多个对象，并定义它们之间的关系

开发：类、继承、多态

#### 面向对象特性

#### 多态

编译时多态（方法的重载），运行时多态（方法的重写）

##### 重载

参数不同 方法相同

##### 重写

子类重写父类

#### 继承

从已有类的信息创建新类的过程，子类继承父类

#### 封装

封装数据和方法，对外提供接口



### 2、jvm、jre、jdk

jdk：java开发工具包，整个java运行的核心，包含运行时jre和java基础类库

jre：java运行环境

jvm：java虚拟机

### 3、构造方法

#### 特性

和类名相同、可以对一些属性、方法进行初始化

自动执行、无需调用 没有返回值

#### 定义无参构造的作用

如果子类没有调用父类的构造方法，默认调用无参构造

### 4、java中创建对象的方法

1、new关键字

2、反射 class.forName.newInstance()

3、clone()方法


### 5、final、finally、finalize的区别

final：申明属性不可以被修改、方法不可以被重写、类不能被继承

finally：异常处理语句的一部分

finallize：object类的方法，垃圾回收的时候会调用被回收对象的finalize



### 6、&和&&区别

都是表示逻辑与的运算符

&& 短路功能 &没有

&可以作为位运算符


### 7、java中参数传递值还是引用

Java 的参数是以值传递的形式传⼊⽅法中，⽽不是引⽤传递。

当传递⽅法参数类型为基本数据类型（数字以及布尔值）时，⼀个⽅法是不可能修改⼀个基本数据类型的参数。

当传递⽅法参数类型为引⽤数据类型时，⼀个⽅法将修改⼀个引⽤数据类型的参数所指向对象的值。即使 Java 函数在传递引⽤数据类型时，也只是拷⻉了引⽤的值罢了，之所以能修改引⽤数据是因为它们同时指向了⼀个对象，但这仍然是按值调⽤⽽不是引⽤调⽤

简单来说，方法参数传递的时候：

基本数据类型，传递的是数据值

引用数据类型，传递的是地址值

所以是值传递，地址值也是值

### 8、如何实现对象的拷贝

1、实现 Cloneable 接⼝并重写 Object 类中的 clone() ⽅法；

2、实现 Serializable 接⼝，通过对象的序列化和反序列化实现克隆，可以实现真正的深克隆。

#### 浅拷贝和深拷贝区别

浅拷贝：只是复制了原对象的地址，任何一个值改变，其余的都会改变

深拷贝：拷贝对象和原对象的地址不同


### 9、对象的创建过程

对象被实例化之前，jvm会检查是否该对象已经被加载并初始化。

没有的话，需要立即去加载目标类，然后调用目标类的构造函数完成初始化。

（对静态变量、成员变量、静态代码块等进行初始化）

初始化完成，根据对象的大小分配内存空间，然后调用init方法


### 10、java有没有指针

没有指针，对象和数组通过引用来处理。

垃圾回收器自动管理对象和数组的内存分配和释放，所有的对象都是通过引用来进行传递的

通过new创建一个新的对象或数组，并将其赋值给引用变量。




### 11、修饰符

public：（任意位置）被修饰的对象或者变量 任何地方都是可见的

protected：（同一个类，同一个包，不同包的子类）对于不同包的类，只有继承该类才能访问

default：（同一个类，同一个包）

private：（同一个类中）

#### 常量的修饰

public static final一起修饰

### 12、序列化和反序列化

#### 概念

序列化是将对象转化为字节流的过程，可以保存到磁盘或者通过网络进行传输

从字节流创建对象称为反序列化

#### 目的

解决网络通信中对象传输的问题。前提要保证传输的可识别性，将对象先转化为通用的解析格式（比如json、xml等格式），再转化为数据流进行网络传输。

#### 实现

被序列化的对象需要实现serializable接口

使⽤⼀个输出流（如：FileOutputStream）来构造⼀个 ObjectOutputStream 对象

使⽤ ObjectOutputStream 对象的 writeObject(Object obj) ⽅法可以将参数为 obj 的对象写出，要恢复的话则使⽤输⼊流。

#### 使用情形

把对象状态保存到一个文件或者数据库中，用套接字在网络上传送对象


### 13、java跨平台

运行java程序的操作系统上，有与操作系统对应的虚拟机

jvm虚拟机不能跨平台，允许跨平台的是java程序


### 14、static关键字的作用

可以修饰普通变量和普通函数，也可以修饰成员变量和成员函数

修饰普通变量和普通函数的时候，只在本源文件中可见，且修饰普通变量时，默认初始化的值为0

修饰成员函数和成员变量的时候，一个类只有这一份，不需要生成对象就可以访问该成员，所有成员共享这一份变量



static关键字用于表示静态成员，用于变量、方法和代码块

#### 静态变量

属于类，不属于类的实例。在类加载的时候被初始化，所有的实例共享同一个变量的值



#### 静态方法

属于类，不属于类的实例。可以直接通过类名调用静态方法，无需创建类的实例。

静态方法不能访问非静态的成员变量和方法



#### 静态代码块

类加载时执行一段代码。在类的静态变量初始化之前执行，并且只执行一次

通常用于进行类的初始化操作



#### static类和普通类的区别

1、static类可以在没有外部类实例的情况下被实例化，普通类必须被实例化才能使用

2、静态嵌套类不能直接访问包含它的外部类的非晶态成员。普通类可以访问它所在的外部类的所有成员，包括非静态成员

3、静态嵌套类可以包含静态成员，普通类也可以包含静态成员

4、静态嵌套类被定义在包含它的外部类的作用域内，但并不是外部类的成员。普通类一般是独立定义的



### 15、环境变量path

当我们运行一个程序，但是没有告诉系统完整路径的时候，除了在当前目录，还会在path指定的路径中去查找，简化启动程序的命令


### 16、多态性和虚函数

#### 多态性

同一个方法或操作可以在不同的对象上具有不同的行为。通过继承和方法重写实现

#### 虚函数

所有的非静态方法默认都是虚函数

# 集合、数据类型

### 1、数据类型、包装类

#### 基本数据类型

byte 1 short 2 int 4 long 8

Float 4 double 8 boolean 1 char 2

都有对应包装类

#### 引用数据类型

String Array set list

#### 空类型

不返回任何值

#### 默认值

0   Null

#### 包装类作用

转化为对象，提供属性和方法，有一些静态方法可以操作

供集合类和泛型使用，集合类中操作元素，是以对象为基础的

包装类的父类是number类，是所有数值型包装类的父类

#### 装箱和拆箱

基本数据类型和包装类型之间的转化

#### int和integer的区别

作为成员变量，int初始值为0，integer初始值为null

integer存储在堆内存，int直接存储在栈空间

#### 隐式转换

基本隐式转换：把一个取值范围小的数值或变量，赋值给一个取值范围大的变量

运算中的隐式转换：byte short char 三种数据运算的时候 都会提升为int 然后再进行运算

#### 强制转换

把取值范围大的数值或变量，赋值给另一个取值范围小的变量

不允许直接赋值，需要加入强制转换

有可能会出现精度损失



扩展赋值运算符，内部自带强转效果

short s=1;

s=s+1;

### 2、equals和==

#### 区别

基本数据类型

== 比较数值

equals不能用于基本数据类型的比较

引用数据类型

== 比较地址值是否相同

equals 比较对象内容是否相同

#### 如何重写equals

如果对象是自己，返回true

如果对象为null或者不是同一类型，返回false

重写需要相同的类型的相等条件



如果要操作集合类hashmap，必须要重写hashcode

（使用hashcode的好处：equals对于大量数据比较过于繁琐，使用hashcode可以快速定位位置，大大减少了开销）

规定：两个对象相等，hashcode一定相同，调用equals方法都返回true

### 3、抽象类和接口的区别

成员权限、抽象方法、静态方法

抽象类：

定义方式：abstract class

可以有抽象方法和具体方法，能定义构造函数

成员权限：public default protected

可以包含静态方法

接口：

定义方式：interface

只有抽象方法

成员权限：public 

没有具体的方法，不能定义构造函数

实现需要在对应实现类中，没有具体的方法体

不可以包含静态方法

### 4、变量

#### 静态变量和实例变量 区别

静态变量：被static修饰的变量 仅有一份拷贝

实例变量：先创建对象，才能访问，属于某一实例



#### This 关键字

区分局部变量和成员变量



#### lambda表达式

简化匿名内部类的写法，只能简化函数式接口

抽象类是不能用lambda表达式进行改写的

语法
	(参数列表)->{方法体}







### 5、object类的常用方法

clone：创建当前对象的拷贝

getClass：返回当前运行时对象的class

toString：转化为字符串

equals：比较两个对象的内存地址是否相等

hashCode：返回哈希值





### 6、遍历数组的方法

for循环遍历

for each遍历

迭代器遍历



#### 数组初始化

动态初始化：手动指定长度，系统分配默认初始化值

静态初始化：手动指定元素，系统根据元素个数，计算出数组的长度



### 7、java中参数传递值还是传引用

传递值

传递方法类型为基本数据类型，方法不可能修改一个基本数据类型的参数

传递方法类型为引用数据类型，方法将修改一个引用参数类型参数指向对象的值

方法参数传递的时候：

基本数据类型，传递的是数据值

引用数据类型，传递的是地址值

值传递，地址值也是值





### 8、集合框架Collection、map

#### Collection包含set、list、queue，collection接口保存数据的目的主要是输出

是最基本的集合接⼝，⼀个 Collection 代表⼀组 Object，即 Collection 的元素。它的直接继承接⼝有List，Set 和 Queue。

#### set-不允许重复元素存在

1、hashset：底层hashmap，hashset的值是作为hashmap中的key存储在hashmap中的

2、treeset：底层红黑树

3、sortedSet->linkedhashset：通过linkedhashmap实现



#### list-有序集合，允许重复元素存在

1、arraylist：底层是动态数组，查找快，添加慢。初始容量为10（指添加元素后，添加元素之前是空数组） 每次扩容后，容量为之前的1.5倍，旧的数组将被回收

arraylist可以添加任意数据类型，但通常限定

list.add()方法返回值一定为true

2、linkedlist：底层是双向链表，不能根据索引查找

3、vector->stack：vector基于数组实现的动态数组。内部使用一个对象数组来存储元素，并支持自动扩容，扩容增加一倍的容量

arraylist和linkedlist线程不安全，但是vector线程是安全的（加了synchronized锁），所以vector性能较低



#### queue

1、deque->arraydeque 双端队列



#### map的子类有hashmap、hashtable、concurrentHashMap、Treemap、linkedhashmap

1、hashmap：基于哈希表实现，无序存放，key或者value可以保存为null

Jdk8 使用链表+红黑树解决冲突问题（哈希冲突：多个键映射到同一个位置）

底层原理：

初始容量是16

使用哈希表存储数据（数组），将一个键值对存储到hashmap中时，首先使用哈希函数对键进行哈希计算，得到一个哈希值。将键映射到哈希表的索引位置上。



冲突处理：哈希函数计算结果可能会导致不同的键映射到相同的索引位置。当多个键值对映射到同一个位置上时，通过链表或红黑树存储

当链表上的元素个数超过 8 个并且数组⻓度 >= 64 时⾃动转化成红⿊树，节点变成树节点，以提⾼搜索效率和插⼊效率到 O(logN)。



扩容：达到阈值时，hashmap会创建一个新的哈希表，大小是原来的两倍，并将原哈希表中的所有元素重信哈希到哈希表中



使用场景：高效的插入、删除、查找操作，不考虑元素的排序顺序

不需要按照特定的顺序遍历元素





2、hashtable：key不能设置为null。线程安全

使用synchronized关键字对整个表进行加锁，效率低

3、treemap：基于红黑树实现，可以按照key排序，key不能重复。不允许null键，允许null值



使用场景：需要获取某个范围的键或值



4、concurrenthashmap：基于分段锁实现（segment）的哈希表，将整个hashmap分成多段，每个段拥有自己的锁，可以支持多线程并发访问，提高并发性能

可以实现多线程的put操作

JDK 7：中 ConcurrentHashMap 采⽤了数组 + Segment + 分段锁的⽅式实现。

JDK 8：中 ConcurrentHashMap 参考了 JDK 8 HashMap 的实现，采⽤了数组 + 链表 + 红⿊树的实现⽅式来设计，内部⼤量采⽤ CAS 操作。



5、linkedhashmap：基于哈希表和双向链表实现，哈希表实现元素的存储和查找，双向链表实现插入和访问顺序。允许null键和null值



#### 关联容器：存储和管理键值对的数据结构



#### arraylist和linkedlist增删查速度比较

1、如果是在末尾，arraylist不需要移动和复制数组来进行操作。如果数据量有百万级，比linkedlist快

2、如果是在中间，数据量有百万级，还是arraylist快

linkedlist的消耗主要在遍历上，arraylist的消耗主要在移动和复制上，linkedlist遍历速度慢于arraylist的复制



#### array和arryalist的区别

1. Array 可以容纳基本类型和对象，⽽ ArrayList 只能容纳对象；
2. Array 是指定⼤⼩的，⽽ ArrayList ⼤⼩是固定的。



1. 如果列表的⼤⼩已经指定，⼤部分情况下是存储和遍历它们；
2. 对于遍历基本数据类型，尽管 Collections 使⽤⾃动装箱来减轻编码任务，在指定⼤⼩的基本类型的列表上⼯作也会变得很慢；

3. 如果你要使⽤多维数组，使⽤array比list更容易





### 9、String类



#### 设计为不可变类

String类为引用类型，不可变，提高字符串的安全性、性能上优化

安全性：不能被修改，避免多线程环境下并发访问问题

缓存和性能优化：先去检查字符串常量池中是否有该字符串相同的值，存在的话，就返回常量池中的引用，避免重复创建相同值的字符串对象，节省了内存空间

允许String对象缓存hashcode：java中String对象的哈希码被频繁使用，比如在hashmap等容器中

被许多java类库用来当作参数：网络连接地址url、文件路径path，如果不是固定不变的，将会引起各种安全隐患。





#### string、stringbuilder、stringbuffer区别

string：用于字符串操作，属于不可变类，每次对string操作都会创建一个新的对象

stringbuilder：线程不安全的可变字符串序列，可以提高字符串的操作效率，可以存储任意数据类型，但是进入这个容器，全部变成字符串

StringBuffer：也⽤于字符串操作，不同之处是 StringBuffer 属于可变类，对⽅法加了同步锁，线程安全





#### string常用方法

indexOf()：返回指定字符的索引。

charAt()：返回指定索引处的字符。

replace()：字符串替换。

trim()：去除字符串两端空⽩。

split()：分割字符串，返回⼀个分割后的字符串数组。

getBytes()：返回字符串的 byte 类型数组。

length()：返回字符串⻓度。

toLowerCase()：将字符串转成⼩写字⺟。

toUpperCase()：将字符串转成⼤写字符。

substring()：截取字符串。

equals()：字符串⽐较



#### 修改字符串的几种方式

1、使用string类中的replace方法，该方法将字符串中某个字符或或字符串替换，并返回一个新的字符串对象

2、使用stringbuilder类，它们提供了修改字符串的方法，例如append() insert() replace() 等 通过这些方法可以对字符串进行修改，并返回一个新的stringbuilder对象，然后使用toString 返回

3、使用字符数组char[]



### 10、数组和链表的使用场景和优缺点

数组是线性数据结构，可以在内存中连续存储多个相同类型的元素。访问元素的时间复杂度为O(1)内存分配连续，空间上相对紧凑，对大量元素的存储比较节省内存。

链表是非连续的数据结构，由一系列节点组成，每个节点包含一个数据元素和一个指向下一个节点的引用。可以动态地插入和删除元素。大小可以动态调整，不受固定大小的限制。



### 11、collections

不属于java的集合框架，是集合类的一个工具类。包含有关集合操作的静态多态方法，实现对各种集合的搜索、排序、线程安全等操作





### 12、如何设计消息队列

可以使用queue集合类来实现消息队列

可以使用线程安全的队列Concurrentlinkedqueue

使用cas操作进行插入和删除，不需要锁





### 13、jdk并发容器

1. ConcurrentHashMap：线程安全的 HashMap；
2. CopyOnWriteArrayList：线程安全的 List，在读多写少的场合性能⾮常好，远远好于 Vector；
3. ConcurrentLinkedQueue：⾼效的并发队列，使⽤链表实现。可以看做⼀个线程安全的 LinkedList，这是⼀

个⾮阻塞队列；

4. BlockingQueue：这是⼀个接⼝，JDK 内部通过链表、数组等⽅式实现了这个接⼝。表示阻塞队列，⾮常适合

⽤于作为数据共享的通道；

5. ConcurrentSkipListMap：跳表的实现。这是⼀个 Map，使⽤跳表的数据结构进⾏快速查找。



### 14、hashmap一系列问题

#### 原理

基于哈希表实现，无序存放，key或者value可以保存为null，初始容量是16

Jdk8 使用链表+红黑树解决冲突问题（哈希冲突：多个键映射到同一个位置）



使用哈希表存储数据（数组），将一个键值对存储到hashmap中时，首先使用哈希函数对键进行哈希计算，得到一个哈希值。将键映射到哈希表的索引位置上。



#### 冲突处理

哈希函数计算结果可能会导致不同的键映射到相同的索引位置。当多个键值对映射到同一个位置上时，通过链表或红黑树存储

当链表上的元素个数超过 8 个并且数组⻓度 >= 64 时⾃动转化成红⿊树，节点变成树节点，以提⾼搜索效率和插⼊效率到 O(logN)。



#### 扩容

默认装载因子是0.75。达到阈值时，hashmap会创建一个新的哈希表，大小是原来的两倍，并将原哈希表中的所有元素重信哈希到哈希表中

#### Put方法执行过程

添加键值对时，先计算key的hash值进行映射到hashmap中的位置。没有元素，则直接插入；有的话，迭代该处元素链表并依次比较其key的hash值。有相等的则覆盖原来的value

#### get方法执行过程

通过key的hash值找到在数组中的索引处的entry，然后返回该key对应的value

#### get方法不能判断某个元素在map中

HashMap 的 get 函数的返回值不能判断⼀个 key 是否包含在 map 中，因为 get 返回 null 有可能是不包含该key，也有可能该 key 对应的 value 为 null。因为 HashMap 中允许 key 为 null，也允许 value 为 null。

#### 死循环问题

主要是多线程同时 put 时，如果同时触发了 rehash 操作，会导致 HashMap 中的链表中出现循环节点，进⽽使得后⾯ get 的时候，会死循环

#### hashmap的size为什么必须是2的整数次方

当 length 为 2 的 n 次⽅时，h & (length - 1)就相当于对 length 取模，⽽且速度⽐直接取模快得多，这是 HashMap 在速度上的⼀个优化。⽽且每次扩容时都是翻倍




