---
title: 面试rush
date: 2025-04-29
updated: 2025-04-29
categories: 面试
tags:
  - 面试
  - 笔记
top: 1
---

## 八股文
### java 基础
1、面向对象特性
继承、多态、封装
2、参数传递值还是引用
值传递。基本数据类型传递数据值，引用数据类型传递地址值
3、对象创建过程
加载字节码文件，执行类的初始化代码，分配内存，赋值，返回对象引用
4、序列化
对象转化为字节流的过程，解决网络中可传输的问题
被序列化对象要实现serializable接口
5、static类和普通类区别
static类可以直接通过外部类的类名实例化，无需先创建外部类的实例
不能直接访问外部类的非静态方法
6、基本数据类型和引用数据类型区别
基本数据类型：变量存储实际数据值，在栈内存中，系统自动管理内存 
引用数据类型：对象存储在堆内存中，引用变量存储在栈内存，垃圾回收机制管理内存
7、equals和==
== 是比较数值，引用数据类型比较地址值
equals 比较引用数据类型，也是地址值
但是string 的equals进行了重写，比较对象是否相同（转化为数组，去遍历）
8、重写equals必须重写hashcode
在操作集合类hashmap的情况下，两个对象相等，hashcode必须相同，不然会映射到不同的桶
9、抽象类和接口的区别
abstract class: 有抽象方法和具体方法 类使用extends继承 提取共同特征、提供默认的实现
interface:默认方法和静态方法 没有构造函数 用implements实现接口  实现多态
10、object类
所有类的父类
11、集合框架 collection map
collection 的继承接口有 list set queue
set:元素不重复 hashset（底层hashmap） treeset（底层红黑树） linkedhashset（通过linkedhashmap实现）
list：有序集合 arraylist（底层动态数组） linkedlist（底层双向链表） vector（动态数组，线程安全，加了synchronized锁）
queue：deque（双端队列）

map 子类 hashmap、hashtable、concurrentHashmap、Treemap、linkedHashmap
hashmap：基于哈希表实现，key或value可以为null 1.8引入红黑树，提高查询、插入效率
hashtable：线程安全 synchronized加锁，效率低
Treemap：基于红黑树，key不能重复
concurrenthashmap：线程安全 1.7 数组 分段锁   1.8 数组链表红黑树 只有在修改某个桶的元素时才加锁 cas操作
linkedhashmap：基于哈希表和双向链表实现 继承了hashmap

12、String为啥设计为不可变类
安全、性能上优化。避免多线程的并发访问问题
先去字符串常量池中找，存在就返回引用，避免重复创建相同值


### jvm
1、内存分布
程序计数器：每个线程都有一个独立的程序计数器，保存字节码文件的地址，控制线程的执行流程

虚拟机栈：每个方法执行时创建一个栈帧

本地方法栈：用于执行本地方法的数据和信息

堆：存放对象实例的内存空间，被所有线程共享  垃圾回收的主要区域 

方法区：各个线程共享的内存区域，用于存储已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据
方法区的一部分，用于存放编译器生成的各种字面量和符号引用。包含了类和接口的常量、字段和方法的符号引用
常量池：可以看作一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等信息

1.8元空间替代了永久代，存放于本地内存中 内存空间大，不容易oom


2、java程序如何在jvm中加载的
方法没有被调用的时候，在方法区的字节码文件存放。被调用时，在栈内存中运行

3、垃圾回收算法
标记清除算法：标记被引用的对象，清除时遍历整个堆，清除未被引用的对象，但是会产生内存碎片
标记复制算法：复制所有存活的对象到另外一片区域，清除原来的区域
标记整理算法：标记所有存活的对象向另一边移动
分代算法：新生代和老年代


4、调优
代码：避免频繁的对象创建和销毁
线程：管理线程资源
内存：设置堆内存大小，调整新生代和老年代的比例



5、排查CPU飙升问题

6、内存泄露
可达的，无用的，不会被gc，但是占用内存的对象
避免方法：尽量少用static成员变量，减少生命周期、及时关闭资源

7、JVM主要组成部分&作用
类加载器：
运行时数据区：
执行引擎：
本地库接口：

⾸先通过类加载器（ClassLoader）会把 Java 代码转换成字节码，运⾏时数据区（Runtime Data Area）再把字节码加载到内存中，⽽字节码⽂件只是 JVM 的⼀套指令集规范，并不能直接交给底层操作系统去执⾏，因此需要特定的命令解析器执⾏引擎（Execution Engine），将字节码翻译成底层系统指令，再交由 CPU 去执⾏，⽽这个过程中需要调⽤其他语⾔的本地库接⼝（Native Interface）来实现整个程序的功能。

8、双亲委派机制
AppClassLoader->ExtClassLoader->BootstrapClassLoader
JVM加载类的时候，会委派给Ext和Bootstrarp进行加载，没加载到才由自己加载
可以避免某一个类被重复加载，当父类已经加载后则无需重复加载，保证唯一性
为了安全，保证类库API不会被修改



### 异常
1、Error类和Exception类区别
Error类和Exception类的父类都是Throwable类
Error类：一般是系统、jvm的问题 方法调用栈溢出（stackoverflow）、堆内存溢出（outofmemory） 靠程序本身无法恢复和预防
Exception类：程序能处理的异常 NPE IO  ClassNotfound

2、finally什么时候会被执行
在return之前，会覆盖其他的return语句
但是不一定执行，try之前异常，或者之前就强制退出

### 高并发


### mysql
1、概念
是客户端/服务器架构的数据库管理系统，用于存储、管理和检索大量结构化数据
连接层：负责与客户端的连接、身份认证和权限管理
管理连接线程，实现线程池复用，提高连接效率
服务层：对sql进行解析，校验表名和列名的合法性，生成最优的执行计划，根据执行计划调用存储引擎接口，执行查询或者更新操作
存储引擎层：负责数据的存储和提取，提供各种存储引擎，如innoDB、MyISAM等
物理存储层：将数据存储在磁盘文件中，包括数据文件、索引文件、日志文件

2、数据库如何优化
使用合适的索引、优化sql语句、调参（内存缓冲区大小、并发连接数）、数据库分区（大表拆成多个分区）

3、索引相关
聚集索引：通常是主键索引，决定了数据在磁盘上的物理存储顺序
非聚集索引：包含索引的键值和指向实际数据行的指针

类型：
B树索引、主键索引（唯一标识表中的每一行数据）、哈希索引（索引值进行hash计算，存储哈希表中，常用语map、set）、唯一索引

4、哪些锁
共享锁（读锁）：可并发读，但是不能写
独占锁（写锁）：只能有一个事务独占


5、mvcc多版本并发控制
每条数据记录都维护多个版本，事务在读取数据时，根据事务id来决定可见的数据版本
事务在读取数据时，根据规则排判断版本是否可见

6、各种日志
binlog：记录数据库增删改查的文件 主从同步
redolog：恢复数据用的日志，保证数据的持久性
undolog：回滚事务

7、mysql什么情况下会索引失效
通过explain判断sql是否失效 看key_len 是整个索引中被索引的数据量
1、违反了最左前缀法则 
不是从左到右查的，key_len为null

2、范围查询右边的列，不能使用索引
status > '1'

3、不要在索引列上进行运算操作，索引将失效

4、字符串不加单引号，造成索引失效，类型转换会造成索引失效

5、以%开头的like模糊查询，索引失效。如果仅仅是尾部模糊匹配，索引不会失效




### mq

### redis


### rpc
1、介绍rpc和原理
远程过程调用，运行程序像调用本地方法一样调用远程计算机上的方法

三个核心：consumer、provider、register
consumer通过注册中心调用provider方法
启动网络服务器的时候，服务提供方向注册中心提供ip 端口号和服务名
consumer通过动态代理对象传输需要调用的方法，经过序列化发送，服务提供方反序列化接受并处理请求返回

2、其他特性
负载均衡：随机、轮询、哈希 避免机器压力过大
集群容错：失败重试
服务降级：mock机制（返回默认值）、快速失败（调用失败时立即抛出异常）
服务路由和灰度发布：方便新版本平滑上线和A/B测试
通信协议：Netty、支持多种协议（HTTP、Hessian）

3、hsf/dubbo有哪些优势？


### spring
1、什么是Spring、为什么要用spring
轻量级的容器框架、依赖注入、控制反转，为了解决业务逻辑层和其他层耦合的问题
好处：提供了对于bean的管理，可以通过注入的方式引用到其他类中，提高代码复用率
生态成熟，整合很多其他的开源库
关键词：控制反转、AOP、容器（管理bean的生命周期）、MVC、事务管理

2、AOP是什么
面向切面编程，将业务处理逻辑和其他公共逻辑分开，比如日志、权限校验等

1、切面（Aspect）：在Spring AOP中 指定就是“切面类”，管理着增强的公共行为代码（通知）和切入方式（切点）
2、连接点（Join point）：指定就是被增强的业务方法
3、通知（Advice）：需要增加到业务方法中的公共代码，有很多种类型，分别可以在需要增加的业务方法不同位置进行执行（前置通知、后置通知、异常通知、返回通知、环绕） 
4、切入点（Pointcut）：由它决定哪些方法需要增强，哪些不需要
5、目标对象（Target Object）：增强的对象
6、织入（Weaving）：

基于代理模式去实现的，目标对象的实现类实现了接口，采用JDK动态代理。没有实现接口，采用CGLIB


3、bean的生命周期
指的是从创建到销毁的整个过程
javaBean：new一个对象进行实例化，不使用的时候进行垃圾回收
SpringBean：被Spring管理的bean
1、实例化：扫描xml文件、注解，查找并加载需要被spring管理的bean，进行bean的实例化（通过反射创建实例）
2、属性赋值：容器根据使用的bean定义的属性值来设置bean实例中的属性，实现依赖注入。
这个阶段解决了循环依赖的问题
3、初始化：调用xxxaware方法  调用初始化生命周期回调  如果bean实现aop 创建动态代理
（1、处理@PostConstruct注解2、处理InitializingBean接口3、进行AOP）
4、销毁：在spring容器关闭的时候进行调用 调用销毁生命周期的回调函数


4、bean的线程安全问题
默认单例，无状态时是安全的，但是如果声明了成员变量并且有读写操作，就会有线程安全问题
解决方法：threadlocal synchonrized concurrentHashmap 

5、ioc的工作流程
IOC的意思是控制反转，把对象的管理权限交给了容器，应用程序如果需要某个对象的实例，直接从IOC容器中获取
本来需要new Service 需要程序员自己创建，现在交给Spring的ioc去创建

工作流程：

1、配置文件加载：spring读取配置文件，根据配置文件内容来加载和实例化对象

2、实例化bean：根据配置文件中的信息实例化bean，创建对象并加入容器中进行管理

3、注入依赖：spring自动解析bean之间的依赖关系，并将依赖注入到对象中

4、生命周期管理：管理对象的生命周期，包括初始化、销毁操作

5、提供bean：提供了统一的接口，可以通过容器来获取bean的实例并使用

6、AOP增强：对bean进行增强和横向切面的功能



6、spring的bean循环依赖如何解决
就是循环引用的问题，A依赖B，B依赖A
通过三级缓存来解决
第一级存储完整的bean实例对象，第二级缓存存储未初始化的bean，第三级缓存存储bean工厂，用来生成原始的bean对象，把bean的实例化和bean的依赖注入进行分离，通过不完整的bean实例解决单例循环依赖问题

但是构造方法的循环依赖spring不能解决，使用@Lazy懒注解，在使用的时候进行注入


7、spring是如何实现事务的
使用@transactioal注解实现的
本质是通过AOP实现的，在方法前后进行拦截，根据执行情况进行提交或者回滚事务

spring的事务隔离级别就是数据库的事务隔离级别
读未提交、读已提交、可重复读、串行化

8、spring的常见注入方式有哪些



9、springmvc是什么 执行流程是怎么样的
Model — View — Controller
模型 视图 控制器
model 程序主体部分，处理业务逻辑和业务数据 view 视图，展现  controller 处理用户输入的数据






自己在整个项目中做的事情 梳理核心链路、gc 慢sql的风险 整理出来 作战手册 

底层结构 接口比较差 风险点 


10、springboot是如何简化spring的繁琐配置的


### 计网

### 概念题

### 场景设计